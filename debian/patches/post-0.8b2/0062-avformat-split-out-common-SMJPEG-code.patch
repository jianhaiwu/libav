From 68b94f8bc3a54735c360c6e72a3698fed8aba10b Mon Sep 17 00:00:00 2001
From: Paul B Mahol <onemda@gmail.com>
Date: Sat, 14 Jan 2012 16:47:07 +0000
Subject: [PATCH 62/67] avformat: split out common SMJPEG code

This is a preparation for adding SMJPEG muxer.

Signed-off-by: Kostya Shishkov <kostya.shishkov@gmail.com>
---
 libavformat/Makefile    |    2 +-
 libavformat/smjpeg.c    |  159 ++----------------------------------------
 libavformat/smjpeg.h    |   45 ++++++++++++
 libavformat/smjpegdec.c |  177 +++++++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 229 insertions(+), 154 deletions(-)
 create mode 100644 libavformat/smjpeg.h
 create mode 100644 libavformat/smjpegdec.c

diff --git a/libavformat/Makefile b/libavformat/Makefile
index 3902e89..3e0808a 100644
--- a/libavformat/Makefile
+++ b/libavformat/Makefile
@@ -274,7 +274,7 @@ OBJS-$(CONFIG_SEGMENT_MUXER)             += segment.o
 OBJS-$(CONFIG_SHORTEN_DEMUXER)           += rawdec.o
 OBJS-$(CONFIG_SIFF_DEMUXER)              += siff.o
 OBJS-$(CONFIG_SMACKER_DEMUXER)           += smacker.o
-OBJS-$(CONFIG_SMJPEG_DEMUXER)            += smjpeg.o
+OBJS-$(CONFIG_SMJPEG_DEMUXER)            += smjpegdec.o smjpeg.o
 OBJS-$(CONFIG_SOL_DEMUXER)               += sol.o pcm.o
 OBJS-$(CONFIG_SOX_DEMUXER)               += soxdec.o pcm.o
 OBJS-$(CONFIG_SOX_MUXER)                 += soxenc.o
diff --git a/libavformat/smjpeg.c b/libavformat/smjpeg.c
index dc94361..573a8a3 100644
--- a/libavformat/smjpeg.c
+++ b/libavformat/smjpeg.c
@@ -1,6 +1,6 @@
 /*
- * SMJPEG demuxer
- * Copyright (c) 2011 Paul B Mahol
+ * SMJPEG common code
+ * Copyright (c) 2011-2012 Paul B Mahol
  *
  * This file is part of Libav.
  *
@@ -21,167 +21,20 @@
 
 /**
  * @file
- * This is a demuxer for Loki SDL Motion JPEG files
+ * SMJPEG common code
  */
 
 #include "avformat.h"
 #include "internal.h"
-#include "riff.h"
+#include "smjpeg.h"
 
-static const AVCodecTag codec_smjpeg_video_tags[] = {
+const AVCodecTag ff_codec_smjpeg_video_tags[] = {
     { CODEC_ID_MJPEG,             MKTAG('J', 'F', 'I', 'F') },
     { CODEC_ID_NONE, 0 },
 };
 
-static const AVCodecTag codec_smjpeg_audio_tags[] = {
+const AVCodecTag ff_codec_smjpeg_audio_tags[] = {
     { CODEC_ID_ADPCM_IMA_SMJPEG,  MKTAG('A', 'P', 'C', 'M') },
     { CODEC_ID_PCM_S16LE,         MKTAG('N', 'O', 'N', 'E') },
     { CODEC_ID_NONE, 0 },
 };
-
-typedef struct SMJPEGContext {
-    int audio_stream_index;
-    int video_stream_index;
-} SMJPEGContext;
-
-static int smjpeg_probe(AVProbeData *p)
-{
-    if (!memcmp(p->buf, "\x0\xaSMJPEG", 8))
-        return AVPROBE_SCORE_MAX;
-    return 0;
-}
-
-static int smjpeg_read_header(AVFormatContext *s, AVFormatParameters *ap)
-{
-    SMJPEGContext *sc = s->priv_data;
-    AVStream *ast = NULL, *vst = NULL;
-    AVIOContext *pb = s->pb;
-    uint32_t version, htype, hlength, duration;
-    char *comment;
-
-    avio_skip(pb, 8); // magic
-    version = avio_rb32(pb);
-    if (version)
-        av_log_ask_for_sample(s, "unknown version %d\n", version);
-
-    duration = avio_rb32(pb); // in msec
-
-    while (!pb->eof_reached) {
-        htype = avio_rl32(pb);
-        switch (htype) {
-        case MKTAG('_', 'T', 'X', 'T'):
-            hlength = avio_rb32(pb);
-            if (!hlength || hlength > 512)
-                return AVERROR_INVALIDDATA;
-            comment = av_malloc(hlength + 1);
-            if (!comment)
-                return AVERROR(ENOMEM);
-            if (avio_read(pb, comment, hlength) != hlength) {
-                av_freep(&comment);
-                av_log(s, AV_LOG_ERROR, "error when reading comment\n");
-                return AVERROR_INVALIDDATA;
-            }
-            comment[hlength] = 0;
-            av_dict_set(&s->metadata, "comment", comment,
-                        AV_DICT_DONT_STRDUP_VAL);
-            break;
-        case MKTAG('_', 'S', 'N', 'D'):
-            if (ast) {
-                av_log_ask_for_sample(s, "multiple audio streams not supported\n");
-                return AVERROR_INVALIDDATA;
-            }
-            hlength = avio_rb32(pb);
-            if (hlength < 8)
-                return AVERROR_INVALIDDATA;
-            ast = avformat_new_stream(s, 0);
-            if (!ast)
-                return AVERROR(ENOMEM);
-            ast->codec->codec_type  = AVMEDIA_TYPE_AUDIO;
-            ast->codec->sample_rate = avio_rb16(pb);
-            ast->codec->bits_per_coded_sample = avio_r8(pb);
-            ast->codec->channels    = avio_r8(pb);
-            ast->codec->codec_tag   = avio_rl32(pb);
-            ast->codec->codec_id    = ff_codec_get_id(codec_smjpeg_audio_tags,
-                                                      ast->codec->codec_tag);
-            ast->duration           = duration;
-            sc->audio_stream_index  = ast->index;
-            avpriv_set_pts_info(ast, 32, 1, 1000);
-            avio_skip(pb, hlength - 8);
-            break;
-        case MKTAG('_', 'V', 'I', 'D'):
-            if (vst) {
-                av_log_ask_for_sample(s, "multiple video streams not supported\n");
-                return AVERROR_INVALIDDATA;
-            }
-            hlength = avio_rb32(pb);
-            if (hlength < 12)
-                return AVERROR_INVALIDDATA;
-            avio_skip(pb, 4); // number of frames
-            vst = avformat_new_stream(s, 0);
-            if (!vst)
-                return AVERROR(ENOMEM);
-            vst->codec->codec_type = AVMEDIA_TYPE_VIDEO;
-            vst->codec->width      = avio_rb16(pb);
-            vst->codec->height     = avio_rb16(pb);
-            vst->codec->codec_tag  = avio_rl32(pb);
-            vst->codec->codec_id   = ff_codec_get_id(codec_smjpeg_video_tags,
-                                                     vst->codec->codec_tag);
-            vst->duration          = duration;
-            sc->video_stream_index = vst->index;
-            avpriv_set_pts_info(vst, 32, 1, 1000);
-            avio_skip(pb, hlength - 12);
-            break;
-        case MKTAG('H', 'E', 'N', 'D'):
-            return 0;
-        default:
-            av_log(s, AV_LOG_ERROR, "unknown header %x\n", htype);
-            return AVERROR_INVALIDDATA;
-        }
-    }
-
-    return AVERROR_EOF;
-}
-
-static int smjpeg_read_packet(AVFormatContext *s, AVPacket *pkt)
-{
-    SMJPEGContext *sc = s->priv_data;
-    uint32_t dtype, ret, size, timestamp;
-
-    if (s->pb->eof_reached)
-        return AVERROR_EOF;
-    dtype = avio_rl32(s->pb);
-    switch (dtype) {
-    case MKTAG('s', 'n', 'd', 'D'):
-        timestamp = avio_rb32(s->pb);
-        size = avio_rb32(s->pb);
-        ret = av_get_packet(s->pb, pkt, size);
-        pkt->stream_index = sc->audio_stream_index;
-        pkt->pts = timestamp;
-        break;
-    case MKTAG('v', 'i', 'd', 'D'):
-        timestamp = avio_rb32(s->pb);
-        size = avio_rb32(s->pb);
-        ret = av_get_packet(s->pb, pkt, size);
-        pkt->stream_index = sc->video_stream_index;
-        pkt->pts = timestamp;
-        break;
-    case MKTAG('D', 'O', 'N', 'E'):
-        ret = AVERROR_EOF;
-        break;
-    default:
-        av_log(s, AV_LOG_ERROR, "unknown chunk %x\n", dtype);
-        ret = AVERROR_INVALIDDATA;
-        break;
-    }
-    return ret;
-}
-
-AVInputFormat ff_smjpeg_demuxer = {
-    .name           = "smjpeg",
-    .long_name      = NULL_IF_CONFIG_SMALL("Loki SDL MJPEG"),
-    .priv_data_size = sizeof(SMJPEGContext),
-    .read_probe     = smjpeg_probe,
-    .read_header    = smjpeg_read_header,
-    .read_packet    = smjpeg_read_packet,
-    .extensions     = "mjpg",
-};
diff --git a/libavformat/smjpeg.h b/libavformat/smjpeg.h
new file mode 100644
index 0000000..c56fe46
--- /dev/null
+++ b/libavformat/smjpeg.h
@@ -0,0 +1,45 @@
+/*
+ * SMJPEG common code
+ * Copyright (c) 2011-2012 Paul B Mahol
+ *
+ * This file is part of Libav.
+ *
+ * Libav is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * Libav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with Libav; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * SMJPEG common code
+ */
+
+#ifndef AVFORMAT_SMJPEG_H
+#define AVFORMAT_SMJPEG_H
+
+#include "internal.h"
+
+#define SMJPEG_MAGIC "\x0\xaSMJPEG"
+
+#define SMJPEG_DONE     MKTAG('D', 'O', 'N', 'E')
+#define SMJPEG_HEND     MKTAG('H', 'E', 'N', 'D')
+#define SMJPEG_SND      MKTAG('_', 'S', 'N', 'D')
+#define SMJPEG_SNDD     MKTAG('s', 'n', 'd', 'D')
+#define SMJPEG_TXT      MKTAG('_', 'T', 'X', 'T')
+#define SMJPEG_VID      MKTAG('_', 'V', 'I', 'D')
+#define SMJPEG_VIDD     MKTAG('v', 'i', 'd', 'D')
+
+extern const AVCodecTag ff_codec_smjpeg_video_tags[];
+extern const AVCodecTag ff_codec_smjpeg_audio_tags[];
+
+#endif /* AVFORMAT_SMJPEG_H */
diff --git a/libavformat/smjpegdec.c b/libavformat/smjpegdec.c
new file mode 100644
index 0000000..d7ff979
--- /dev/null
+++ b/libavformat/smjpegdec.c
@@ -0,0 +1,177 @@
+/*
+ * SMJPEG demuxer
+ * Copyright (c) 2011 Paul B Mahol
+ *
+ * This file is part of Libav.
+ *
+ * Libav is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * Libav is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with Libav; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * This is a demuxer for Loki SDL Motion JPEG files
+ */
+
+#include "avformat.h"
+#include "internal.h"
+#include "riff.h"
+#include "smjpeg.h"
+
+typedef struct SMJPEGContext {
+    int audio_stream_index;
+    int video_stream_index;
+} SMJPEGContext;
+
+static int smjpeg_probe(AVProbeData *p)
+{
+    if (!memcmp(p->buf, SMJPEG_MAGIC, 8))
+        return AVPROBE_SCORE_MAX;
+    return 0;
+}
+
+static int smjpeg_read_header(AVFormatContext *s, AVFormatParameters *ap)
+{
+    SMJPEGContext *sc = s->priv_data;
+    AVStream *ast = NULL, *vst = NULL;
+    AVIOContext *pb = s->pb;
+    uint32_t version, htype, hlength, duration;
+    char *comment;
+
+    avio_skip(pb, 8); // magic
+    version = avio_rb32(pb);
+    if (version)
+        av_log_ask_for_sample(s, "unknown version %d\n", version);
+
+    duration = avio_rb32(pb); // in msec
+
+    while (!pb->eof_reached) {
+        htype = avio_rl32(pb);
+        switch (htype) {
+        case SMJPEG_TXT:
+            hlength = avio_rb32(pb);
+            if (!hlength || hlength > 512)
+                return AVERROR_INVALIDDATA;
+            comment = av_malloc(hlength + 1);
+            if (!comment)
+                return AVERROR(ENOMEM);
+            if (avio_read(pb, comment, hlength) != hlength) {
+                av_freep(&comment);
+                av_log(s, AV_LOG_ERROR, "error when reading comment\n");
+                return AVERROR_INVALIDDATA;
+            }
+            comment[hlength] = 0;
+            av_dict_set(&s->metadata, "comment", comment,
+                        AV_DICT_DONT_STRDUP_VAL);
+            break;
+        case SMJPEG_SND:
+            if (ast) {
+                av_log_ask_for_sample(s, "multiple audio streams not supported\n");
+                return AVERROR_INVALIDDATA;
+            }
+            hlength = avio_rb32(pb);
+            if (hlength < 8)
+                return AVERROR_INVALIDDATA;
+            ast = avformat_new_stream(s, 0);
+            if (!ast)
+                return AVERROR(ENOMEM);
+            ast->codec->codec_type  = AVMEDIA_TYPE_AUDIO;
+            ast->codec->sample_rate = avio_rb16(pb);
+            ast->codec->bits_per_coded_sample = avio_r8(pb);
+            ast->codec->channels    = avio_r8(pb);
+            ast->codec->codec_tag   = avio_rl32(pb);
+            ast->codec->codec_id    = ff_codec_get_id(ff_codec_smjpeg_audio_tags,
+                                                      ast->codec->codec_tag);
+            ast->duration           = duration;
+            sc->audio_stream_index  = ast->index;
+            avpriv_set_pts_info(ast, 32, 1, 1000);
+            avio_skip(pb, hlength - 8);
+            break;
+        case SMJPEG_VID:
+            if (vst) {
+                av_log_ask_for_sample(s, "multiple video streams not supported\n");
+                return AVERROR_INVALIDDATA;
+            }
+            hlength = avio_rb32(pb);
+            if (hlength < 12)
+                return AVERROR_INVALIDDATA;
+            avio_skip(pb, 4); // number of frames
+            vst = avformat_new_stream(s, 0);
+            if (!vst)
+                return AVERROR(ENOMEM);
+            vst->codec->codec_type = AVMEDIA_TYPE_VIDEO;
+            vst->codec->width      = avio_rb16(pb);
+            vst->codec->height     = avio_rb16(pb);
+            vst->codec->codec_tag  = avio_rl32(pb);
+            vst->codec->codec_id   = ff_codec_get_id(ff_codec_smjpeg_video_tags,
+                                                     vst->codec->codec_tag);
+            vst->duration          = duration;
+            sc->video_stream_index = vst->index;
+            avpriv_set_pts_info(vst, 32, 1, 1000);
+            avio_skip(pb, hlength - 12);
+            break;
+        case SMJPEG_HEND:
+            return 0;
+        default:
+            av_log(s, AV_LOG_ERROR, "unknown header %x\n", htype);
+            return AVERROR_INVALIDDATA;
+        }
+    }
+
+    return AVERROR_EOF;
+}
+
+static int smjpeg_read_packet(AVFormatContext *s, AVPacket *pkt)
+{
+    SMJPEGContext *sc = s->priv_data;
+    uint32_t dtype, ret, size, timestamp;
+
+    if (s->pb->eof_reached)
+        return AVERROR_EOF;
+    dtype = avio_rl32(s->pb);
+    switch (dtype) {
+    case SMJPEG_SNDD:
+        timestamp = avio_rb32(s->pb);
+        size = avio_rb32(s->pb);
+        ret = av_get_packet(s->pb, pkt, size);
+        pkt->stream_index = sc->audio_stream_index;
+        pkt->pts = timestamp;
+        break;
+    case SMJPEG_VIDD:
+        timestamp = avio_rb32(s->pb);
+        size = avio_rb32(s->pb);
+        ret = av_get_packet(s->pb, pkt, size);
+        pkt->stream_index = sc->video_stream_index;
+        pkt->pts = timestamp;
+        break;
+    case SMJPEG_DONE:
+        ret = AVERROR_EOF;
+        break;
+    default:
+        av_log(s, AV_LOG_ERROR, "unknown chunk %x\n", dtype);
+        ret = AVERROR_INVALIDDATA;
+        break;
+    }
+    return ret;
+}
+
+AVInputFormat ff_smjpeg_demuxer = {
+    .name           = "smjpeg",
+    .long_name      = NULL_IF_CONFIG_SMALL("Loki SDL MJPEG"),
+    .priv_data_size = sizeof(SMJPEGContext),
+    .read_probe     = smjpeg_probe,
+    .read_header    = smjpeg_read_header,
+    .read_packet    = smjpeg_read_packet,
+    .extensions     = "mjpg",
+};
-- 
1.7.5.4


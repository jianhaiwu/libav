From d859191322d8596b6d4219269db96456267f0d04 Mon Sep 17 00:00:00 2001
From: Laurentiu Ion <ionlaurentiucristian@gmail.com>
Date: Mon, 16 Jan 2012 04:47:07 +0200
Subject: [PATCH 61/63] pictordec: Use bytestream2 functions

Signed-off-by: Justin Ruggles <justin.ruggles@gmail.com>
---
 libavcodec/pictordec.c |   99 +++++++++++++++++++++++++++---------------------
 1 files changed, 56 insertions(+), 43 deletions(-)

diff --git a/libavcodec/pictordec.c b/libavcodec/pictordec.c
index 732583e..e0bc899 100644
--- a/libavcodec/pictordec.c
+++ b/libavcodec/pictordec.c
@@ -33,6 +33,7 @@ typedef struct PicContext {
     AVFrame frame;
     int width, height;
     int nb_planes;
+    GetByteContext g;
 } PicContext;
 
 static void picmemset_8bpp(PicContext *s, int value, int run, int *x, int *y)
@@ -55,7 +56,8 @@ static void picmemset_8bpp(PicContext *s, int value, int run, int *x, int *y)
     }
 }
 
-static void picmemset(PicContext *s, int value, int run, int *x, int *y, int *plane, int bits_per_plane)
+static void picmemset(PicContext *s, int value, int run,
+                      int *x, int *y, int *plane, int bits_per_plane)
 {
     uint8_t *d;
     int shift = *plane * bits_per_plane;
@@ -99,34 +101,35 @@ static int decode_frame(AVCodecContext *avctx,
                         AVPacket *avpkt)
 {
     PicContext *s = avctx->priv_data;
-    int buf_size = avpkt->size;
-    const uint8_t *buf = avpkt->data;
-    const uint8_t *buf_end = avpkt->data + buf_size;
     uint32_t *palette;
-    int bits_per_plane, bpp, etype, esize, npal;
-    int i, x, y, plane;
+    int bits_per_plane, bpp, etype, esize, npal, pos_after_pal;
+    int i, x, y, plane, tmp;
 
-    if (buf_size < 11)
+    bytestream2_init(&s->g, avpkt->data, avpkt->size);
+
+    if (bytestream2_get_bytes_left(&s->g) < 11)
         return AVERROR_INVALIDDATA;
 
-    if (bytestream_get_le16(&buf) != 0x1234)
+    if (bytestream2_get_le16u(&s->g) != 0x1234)
         return AVERROR_INVALIDDATA;
-    s->width  = bytestream_get_le16(&buf);
-    s->height = bytestream_get_le16(&buf);
-    buf += 4;
-    bits_per_plane    = *buf & 0xF;
-    s->nb_planes      = (*buf++ >> 4) + 1;
-    bpp               = s->nb_planes ? bits_per_plane*s->nb_planes : bits_per_plane;
+
+    s->width       = bytestream2_get_le16u(&s->g);
+    s->height      = bytestream2_get_le16u(&s->g);
+    bytestream2_skip(&s->g, 4);
+    tmp            = bytestream2_get_byteu(&s->g);
+    bits_per_plane = tmp & 0xF;
+    s->nb_planes   = (tmp >> 4) + 1;
+    bpp            = bits_per_plane * s->nb_planes;
     if (bits_per_plane > 8 || bpp < 1 || bpp > 32) {
         av_log_ask_for_sample(s, "unsupported bit depth\n");
         return AVERROR_INVALIDDATA;
     }
 
-    if (*buf == 0xFF) {
-        buf += 2;
-        etype  = bytestream_get_le16(&buf);
-        esize  = bytestream_get_le16(&buf);
-        if (buf_end - buf < esize)
+    if (bytestream2_peek_byte(&s->g) == 0xFF) {
+        bytestream2_skip(&s->g, 2);
+        etype = bytestream2_get_le16(&s->g);
+        esize = bytestream2_get_le16(&s->g);
+        if (bytestream2_get_bytes_left(&s->g) < esize)
             return AVERROR_INVALIDDATA;
     } else {
         etype = -1;
@@ -151,24 +154,29 @@ static int decode_frame(AVCodecContext *avctx,
     s->frame.pict_type           = AV_PICTURE_TYPE_I;
     s->frame.palette_has_changed = 1;
 
+    pos_after_pal = bytestream2_tell(&s->g) + esize;
     palette = (uint32_t*)s->frame.data[1];
-    if (etype == 1 && esize > 1 && *buf < 6) {
-        int idx = *buf;
+    if (etype == 1 && esize > 1 && bytestream2_peek_byte(&s->g) < 6) {
+        int idx = bytestream2_get_byte(&s->g);
         npal = 4;
         for (i = 0; i < npal; i++)
             palette[i] = ff_cga_palette[ cga_mode45_index[idx][i] ];
     } else if (etype == 2) {
         npal = FFMIN(esize, 16);
-        for (i = 0; i < npal; i++)
-            palette[i] = ff_cga_palette[ FFMIN(buf[i], 16)];
+        for (i = 0; i < npal; i++) {
+            int pal_idx = bytestream2_get_byte(&s->g);
+            palette[i]  = ff_cga_palette[FFMIN(pal_idx, 16)];
+        }
     } else if (etype == 3) {
         npal = FFMIN(esize, 16);
-        for (i = 0; i < npal; i++)
-            palette[i] = ff_ega_palette[ FFMIN(buf[i], 63)];
+        for (i = 0; i < npal; i++) {
+            int pal_idx = bytestream2_get_byte(&s->g);
+            palette[i]  = ff_ega_palette[FFMIN(pal_idx, 63)];
+        }
     } else if (etype == 4 || etype == 5) {
         npal = FFMIN(esize / 3, 256);
         for (i = 0; i < npal; i++)
-            palette[i] = AV_RB24(buf + i*3) << 2;
+            palette[i] = bytestream2_get_be24(&s->g) << 2;
     } else {
         if (bpp == 1) {
             npal = 2;
@@ -185,29 +193,34 @@ static int decode_frame(AVCodecContext *avctx,
     }
     // fill remaining palette entries
     memset(palette + npal, 0, AVPALETTE_SIZE - npal * 4);
-    buf += esize;
-
+    // skip remaining palette bytes
+    bytestream2_seek(&s->g, pos_after_pal, SEEK_SET);
 
     x = 0;
     y = s->height - 1;
     plane = 0;
-    if (bytestream_get_le16(&buf)) {
-        while (buf_end - buf >= 6) {
-            const uint8_t *buf_pend = buf + FFMIN(AV_RL16(buf), buf_end - buf);
-            //ignore uncompressed block size reported at buf[2]
-            int marker = buf[4];
-            buf += 5;
-
-            while (plane < s->nb_planes && buf_pend - buf >= 1) {
+    if (bytestream2_get_le16(&s->g)) {
+        while (bytestream2_get_bytes_left(&s->g) >= 6) {
+            int stop_size, marker, t1, t2;
+
+            t1        = bytestream2_get_bytes_left(&s->g);
+            t2        = bytestream2_get_le16(&s->g);
+            stop_size = t1 - FFMIN(t1, t2);
+            // ignore uncompressed block size
+            bytestream2_skip(&s->g, 2);
+            marker    = bytestream2_get_byte(&s->g);
+
+            while (plane < s->nb_planes &&
+                   bytestream2_get_bytes_left(&s->g) > stop_size) {
                 int run = 1;
-                int val = *buf++;
+                int val = bytestream2_get_byte(&s->g);
                 if (val == marker) {
-                    run = *buf++;
+                    run = bytestream2_get_byte(&s->g);
                     if (run == 0)
-                        run = bytestream_get_le16(&buf);
-                    val = *buf++;
+                        run = bytestream2_get_le16(&s->g);
+                    val = bytestream2_get_byte(&s->g);
                 }
-                if (buf > buf_end)
+                if (!bytestream2_get_bytes_left(&s->g))
                     break;
 
                 if (bits_per_plane == 8) {
@@ -221,12 +234,12 @@ static int decode_frame(AVCodecContext *avctx,
         }
     } else {
         av_log_ask_for_sample(s, "uncompressed image\n");
-        return buf_size;
+        return avpkt->size;
     }
 
     *data_size = sizeof(AVFrame);
     *(AVFrame*)data = s->frame;
-    return buf_size;
+    return avpkt->size;
 }
 
 static av_cold int decode_end(AVCodecContext *avctx)
-- 
1.7.5.4


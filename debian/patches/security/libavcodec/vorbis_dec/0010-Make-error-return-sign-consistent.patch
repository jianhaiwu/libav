From 213d02328757c6b212ac6d4bb7ec23f70080fb25 Mon Sep 17 00:00:00 2001
From: michael <michael@9553f0bf-9b14-0410-a0b8-cfaf0461ba5b>
Date: Wed, 23 Sep 2009 13:18:29 +0000
Subject: [PATCH 10/12] Make error return sign consistent.

edited by siretart@tauware.de to apply to 0.5

git-svn-id: file:///var/local/repositories/ffmpeg/trunk@19997 9553f0bf-9b14-0410-a0b8-cfaf0461ba5b
---
 libavcodec/vorbis_dec.c |   60 +++++++++++++++++++++++-----------------------
 1 files changed, 30 insertions(+), 30 deletions(-)

--- a/libavcodec/vorbis_dec.c
+++ b/libavcodec/vorbis_dec.c
@@ -418,7 +418,7 @@ static int vorbis_parse_setup_hdr_codebo
 error:
     av_free(tmp_vlc_bits);
     av_free(tmp_vlc_codes);
-    return 1;
+    return -1;
 }
 
 // Process time domain transforms part (unused in Vorbis I)
@@ -435,7 +435,7 @@ static int vorbis_parse_setup_hdr_tdtran
 
         if (vorbis_tdtransform) {
             av_log(vc->avccontext, AV_LOG_ERROR, "Vorbis time domain transform data nonzero. \n");
-            return 1;
+            return -1;
         }
     }
     return 0;
@@ -496,7 +496,7 @@ static int vorbis_parse_setup_hdr_floors
                     int bits=get_bits(gb, 8);
                     if (bits>=vc->codebook_count) {
                         av_log(vc->avccontext, AV_LOG_ERROR, "Masterbook index %d is out of range.\n", bits);
-                        return 1;
+                        return -1;
                     }
                     floor_setup->data.t1.class_masterbook[j]=bits;
 
@@ -507,7 +507,7 @@ static int vorbis_parse_setup_hdr_floors
                     int16_t bits=get_bits(gb, 8)-1;
                     if (bits!=-1 && bits>=vc->codebook_count) {
                         av_log(vc->avccontext, AV_LOG_ERROR, "Subclass book index %d is out of range.\n", bits);
-                        return 1;
+                        return -1;
                     }
                     floor_setup->data.t1.subclass_books[j][k]=bits;
 
@@ -554,7 +554,7 @@ static int vorbis_parse_setup_hdr_floors
             if (floor_setup->data.t0.amplitude_bits == 0) {
               av_log(vc->avccontext, AV_LOG_ERROR,
                      "Floor 0 amplitude bits is 0.\n");
-              return 1;
+              return -1;
             }
             floor_setup->data.t0.amplitude_offset=get_bits(gb, 8);
             floor_setup->data.t0.num_books=get_bits(gb, 4)+1;
@@ -562,7 +562,7 @@ static int vorbis_parse_setup_hdr_floors
             /* allocate mem for booklist */
             floor_setup->data.t0.book_list=
                 av_malloc(floor_setup->data.t0.num_books);
-            if(!floor_setup->data.t0.book_list) { return 1; }
+            if(!floor_setup->data.t0.book_list) { return -1; }
             /* read book indexes */
             {
                 int idx;
@@ -570,7 +570,7 @@ static int vorbis_parse_setup_hdr_floors
                 for (idx=0;idx<floor_setup->data.t0.num_books;++idx) {
                     book_idx=get_bits(gb, 8);
                     if (book_idx>=vc->codebook_count)
-                        return 1;
+                        return -1;
                     floor_setup->data.t0.book_list[idx]=book_idx;
                     if (vc->codebooks[book_idx].dimensions > max_codebook_dim)
                         max_codebook_dim=vc->codebooks[book_idx].dimensions;
@@ -586,7 +586,7 @@ static int vorbis_parse_setup_hdr_floors
                 floor_setup->data.t0.lsp=
                     av_malloc((floor_setup->data.t0.order+1 + max_codebook_dim)
                               * sizeof(float));
-                if(!floor_setup->data.t0.lsp) { return 1; }
+                if(!floor_setup->data.t0.lsp) { return -1; }
             }
 
 #ifdef V_DEBUG /* debug output parsed headers */
@@ -614,7 +614,7 @@ static int vorbis_parse_setup_hdr_floors
         }
         else {
             av_log(vc->avccontext, AV_LOG_ERROR, "Invalid floor type!\n");
-            return 1;
+            return -1;
         }
     }
     return 0;
@@ -649,14 +649,14 @@ static int vorbis_parse_setup_hdr_residu
         || res_setup->end>vc->blocksize[1]/(res_setup->type==2?1:2)
         || (res_setup->end-res_setup->begin)/res_setup->partition_size>V_MAX_PARTITIONS) {
             av_log(vc->avccontext, AV_LOG_ERROR, "partition out of bounds: type, begin, end, size, blocksize: %d, %d, %d, %d, %d\n", res_setup->type, res_setup->begin, res_setup->end, res_setup->partition_size, vc->blocksize[1]/2);
-            return 1;
+            return -1;
         }
 
         res_setup->classifications=get_bits(gb, 6)+1;
         res_setup->classbook=get_bits(gb, 8);
         if (res_setup->classbook>=vc->codebook_count) {
             av_log(vc->avccontext, AV_LOG_ERROR, "classbook value %d out of range. \n", res_setup->classbook);
-            return 1;
+            return -1;
         }
 
         AV_DEBUG("    begin %d end %d part.size %d classif.s %d classbook %d \n", res_setup->begin, res_setup->end, res_setup->partition_size,
@@ -680,7 +680,7 @@ static int vorbis_parse_setup_hdr_residu
                     int bits=get_bits(gb, 8);
                     if (bits>=vc->codebook_count) {
                         av_log(vc->avccontext, AV_LOG_ERROR, "book value %d out of range. \n", bits);
-                        return 1;
+                        return -1;
                     }
                     res_setup->books[j][k]=bits;
 
@@ -714,7 +714,7 @@ static int vorbis_parse_setup_hdr_mappin
 
         if (get_bits(gb, 16)) {
             av_log(vc->avccontext, AV_LOG_ERROR, "Other mappings than type 0 are not compliant with the Vorbis I specification. \n");
-            return 1;
+            return -1;
         }
         if (get_bits1(gb)) {
             mapping_setup->submaps=get_bits(gb, 4)+1;
@@ -731,11 +731,11 @@ static int vorbis_parse_setup_hdr_mappin
                 mapping_setup->angle[j]=get_bits(gb, ilog(vc->audio_channels-1));
                 if (mapping_setup->magnitude[j]>=vc->audio_channels) {
                     av_log(vc->avccontext, AV_LOG_ERROR, "magnitude channel %d out of range. \n", mapping_setup->magnitude[j]);
-                    return 1;
+                    return -1;
                 }
                 if (mapping_setup->angle[j]>=vc->audio_channels) {
                     av_log(vc->avccontext, AV_LOG_ERROR, "angle channel %d out of range. \n", mapping_setup->angle[j]);
-                    return 1;
+                    return -1;
                 }
             }
         } else {
@@ -746,7 +746,7 @@ static int vorbis_parse_setup_hdr_mappin
 
         if(get_bits(gb, 2)) {
             av_log(vc->avccontext, AV_LOG_ERROR, "%d. mapping setup data invalid. \n", i);
-            return 1; // following spec.
+            return -1; // following spec.
         }
 
         if (mapping_setup->submaps>1) {
@@ -825,7 +825,7 @@ static int vorbis_parse_setup_hdr_modes(
         mode_setup->mapping=get_bits(gb, 8);
         if (mode_setup->mapping>=vc->mapping_count) {
             av_log(vc->avccontext, AV_LOG_ERROR, "mode mapping value %d out of range. \n", mode_setup->mapping);
-            return 1;
+            return -1;
         }
 
         AV_DEBUG(" %d mode: blockflag %d, windowtype %d, transformtype %d, mapping %d \n", i, mode_setup->blockflag, mode_setup->windowtype, mode_setup->transformtype, mode_setup->mapping);
@@ -842,36 +842,36 @@ static int vorbis_parse_setup_hdr(vorbis
     (get_bits(gb, 8)!='r') || (get_bits(gb, 8)!='b') ||
     (get_bits(gb, 8)!='i') || (get_bits(gb, 8)!='s')) {
         av_log(vc->avccontext, AV_LOG_ERROR, " Vorbis setup header packet corrupt (no vorbis signature). \n");
-        return 1;
+        return -1;
     }
 
     if (vorbis_parse_setup_hdr_codebooks(vc)) {
         av_log(vc->avccontext, AV_LOG_ERROR, " Vorbis setup header packet corrupt (codebooks). \n");
-        return 2;
+        return -2;
     }
     if (vorbis_parse_setup_hdr_tdtransforms(vc)) {
         av_log(vc->avccontext, AV_LOG_ERROR, " Vorbis setup header packet corrupt (time domain transforms). \n");
-        return 3;
+        return -3;
     }
     if (vorbis_parse_setup_hdr_floors(vc)) {
         av_log(vc->avccontext, AV_LOG_ERROR, " Vorbis setup header packet corrupt (floors). \n");
-        return 4;
+        return -4;
     }
     if (vorbis_parse_setup_hdr_residues(vc)) {
         av_log(vc->avccontext, AV_LOG_ERROR, " Vorbis setup header packet corrupt (residues). \n");
-        return 5;
+        return -5;
     }
     if (vorbis_parse_setup_hdr_mappings(vc)) {
         av_log(vc->avccontext, AV_LOG_ERROR, " Vorbis setup header packet corrupt (mappings). \n");
-        return 6;
+        return -6;
     }
     if (vorbis_parse_setup_hdr_modes(vc)) {
         av_log(vc->avccontext, AV_LOG_ERROR, " Vorbis setup header packet corrupt (modes). \n");
-        return 7;
+        return -7;
     }
     if (!get_bits1(gb)) {
         av_log(vc->avccontext, AV_LOG_ERROR, " Vorbis setup header packet corrupt (framing flag). \n");
-        return 8; // framing flag bit unset error
+        return -8; // framing flag bit unset error
     }
 
     return 0;
@@ -887,7 +887,7 @@ static int vorbis_parse_id_hdr(vorbis_co
     (get_bits(gb, 8)!='r') || (get_bits(gb, 8)!='b') ||
     (get_bits(gb, 8)!='i') || (get_bits(gb, 8)!='s')) {
         av_log(vc->avccontext, AV_LOG_ERROR, " Vorbis id header packet corrupt (no vorbis signature). \n");
-        return 1;
+        return -1;
     }
 
     vc->version=get_bits_long(gb, 32);    //FIXME check 0
@@ -902,14 +902,14 @@ static int vorbis_parse_id_hdr(vorbis_co
     vc->blocksize[1]=(1<<bl1);
     if (bl0>13 || bl0<6 || bl1>13 || bl1<6 || bl1<bl0) {
         av_log(vc->avccontext, AV_LOG_ERROR, " Vorbis id header packet corrupt (illegal blocksize). \n");
-        return 3;
+        return -3;
     }
     // output format int16
     if (vc->blocksize[1]/2 * vc->audio_channels * 2 >
                                              AVCODEC_MAX_AUDIO_FRAME_SIZE) {
         av_log(vc->avccontext, AV_LOG_ERROR, "Vorbis channel count makes "
                "output packets too large.\n");
-        return 4;
+        return -4;
     }
     vc->win[0]=ff_vorbis_vwin[bl0-6];
     vc->win[1]=ff_vorbis_vwin[bl1-6];
@@ -926,7 +926,7 @@ static int vorbis_parse_id_hdr(vorbis_co
 
     if ((get_bits1(gb)) == 0) {
         av_log(vc->avccontext, AV_LOG_ERROR, " Vorbis id header packet corrupt (framing flag not set). \n");
-        return 2;
+        return -2;
     }
 
     vc->channel_residues= av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));
@@ -1415,7 +1415,7 @@ static inline int vorbis_residue_decode(
         return vorbis_residue_decode_internal(vc, vr, ch, do_not_decode, vec, vlen, 0);
     else {
         av_log(vc->avccontext, AV_LOG_ERROR, " Invalid residue type while residue decode?! \n");
-        return 1;
+        return -1;
     }
 }
 

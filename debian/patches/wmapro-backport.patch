From: Christopher Martin <chrsmrtn@debian.org>
Bug: http://bugs.debian.org/559712

--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -214,6 +214,7 @@
     REGISTER_DECODER (VMDAUDIO, vmdaudio);
     REGISTER_ENCDEC  (VORBIS, vorbis);
     REGISTER_DECODER (WAVPACK, wavpack);
+    REGISTER_DECODER (WMAPRO, wmapro);
     REGISTER_ENCDEC  (WMAV1, wmav1);
     REGISTER_ENCDEC  (WMAV2, wmav2);
     REGISTER_DECODER (WS_SND1, ws_snd1);
--- a/libavcodec/dsputil.c
+++ b/libavcodec/dsputil.c
@@ -4043,6 +4043,12 @@
         dst[i*step] = src0[i] * src1[i] + src2[i] + src3;
 }
 
+static void vector_fmul_add_c(float *dst, const float *src0, const float *src1, const float *src2, int len){
+    int i;
+    for(i=0; i<len; i++)
+        dst[i] = src0[i] * src1[i] + src2[i];
+}
+
 void ff_vector_fmul_window_c(float *dst, const float *src0, const float *src1, const float *win, float add_bias, int len){
     int i,j;
     dst += len;
@@ -4058,6 +4064,25 @@
     }
 }
 
+static void vector_fmul_scalar_c(float *dst, const float *src, float mul,
+                                 int len)
+{
+    int i;
+    for (i = 0; i < len; i++)
+        dst[i] = src[i] * mul;
+}
+
+static void butterflies_float_c(float *restrict v1, float *restrict v2,
+                                int len)
+{
+    int i;
+    for (i = 0; i < len; i++) {
+        float t = v1[i] - v2[i];
+        v1[i] += v2[i];
+        v2[i] = t;
+    }
+}
+
 static void int32_to_float_fmul_scalar_c(float *dst, const int *src, float mul, int len){
     int i;
     for(i=0; i<len; i++)
@@ -4633,6 +4658,7 @@
     c->vector_fmul = vector_fmul_c;
     c->vector_fmul_reverse = vector_fmul_reverse_c;
     c->vector_fmul_add_add = ff_vector_fmul_add_add_c;
+    c->vector_fmul_add = vector_fmul_add_c;
     c->vector_fmul_window = ff_vector_fmul_window_c;
     c->int32_to_float_fmul_scalar = int32_to_float_fmul_scalar_c;
     c->float_to_int16 = ff_float_to_int16_c;
@@ -4640,6 +4666,8 @@
     c->add_int16 = add_int16_c;
     c->sub_int16 = sub_int16_c;
     c->scalarproduct_int16 = scalarproduct_int16_c;
+    c->butterflies_float = butterflies_float_c;
+    c->vector_fmul_scalar = vector_fmul_scalar_c;
 
     c->shrink[0]= ff_img_copy_plane;
     c->shrink[1]= ff_shrink22;
--- a/libavcodec/dsputil.h
+++ b/libavcodec/dsputil.h
@@ -391,10 +391,13 @@
     void (*vector_fmul_reverse)(float *dst, const float *src0, const float *src1, int len);
     /* assume len is a multiple of 8, and src arrays are 16-byte aligned */
     void (*vector_fmul_add_add)(float *dst, const float *src0, const float *src1, const float *src2, int src3, int len, int step);
+    void (*vector_fmul_add)(float *dst, const float *src0, const float *src1, const float *src2, int len);
     /* assume len is a multiple of 4, and arrays are 16-byte aligned */
     void (*vector_fmul_window)(float *dst, const float *src0, const float *src1, const float *win, float add_bias, int len);
     /* assume len is a multiple of 8, and arrays are 16-byte aligned */
     void (*int32_to_float_fmul_scalar)(float *dst, const int *src, float mul, int len);
+    void (*vector_fmul_scalar)(float *dst, const float *src, float mul, int len);
+    void (*butterflies_float)(float *restrict v1, float *restrict v2, int len);
 
     /* C version: convert floats from the range [384.0,386.0] to ints in [-32768,32767]
      * simd versions: convert floats from [-32768.0,32767.0] without rescaling and arrays are 16byte aligned */
@@ -758,6 +761,7 @@
 extern float *ff_sine_windows[6];
 
 int ff_mdct_init(MDCTContext *s, int nbits, int inverse);
+int ff_mdct_init_backport(MDCTContext *s, int nbits, int inverse, double scale);
 void ff_imdct_calc_c(MDCTContext *s, FFTSample *output, const FFTSample *input);
 void ff_imdct_half_c(MDCTContext *s, FFTSample *output, const FFTSample *input);
 void ff_imdct_calc_3dn(MDCTContext *s, FFTSample *output, const FFTSample *input);
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -236,6 +236,7 @@
 OBJS-$(CONFIG_VP6F_DECODER)            += vp6.o vp56.o vp56data.o vp3dsp.o vp6dsp.o huffman.o
 OBJS-$(CONFIG_VQA_DECODER)             += vqavideo.o
 OBJS-$(CONFIG_WAVPACK_DECODER)         += wavpack.o
+OBJS-$(CONFIG_WMAPRO_DECODER)          += wmaprodec.o wma.o
 OBJS-$(CONFIG_WMAV1_DECODER)           += wmadec.o wma.o
 OBJS-$(CONFIG_WMAV1_ENCODER)           += wmaenc.o wma.o
 OBJS-$(CONFIG_WMAV2_DECODER)           += wmadec.o wma.o
--- a/libavcodec/mdct.c
+++ b/libavcodec/mdct.c
@@ -99,6 +99,39 @@
     return -1;
 }
 
+av_cold int ff_mdct_init_backport(MDCTContext *s, int nbits, int inverse, double scale)
+{
+    int n, n4, i;
+    double alpha, theta;
+
+    memset(s, 0, sizeof(*s));
+    n = 1 << nbits;
+    s->nbits = nbits;
+    s->n = n;
+    n4 = n >> 2;
+    s->tcos = av_malloc(n4 * sizeof(FFTSample));
+    if (!s->tcos)
+        goto fail;
+    s->tsin = av_malloc(n4 * sizeof(FFTSample));
+    if (!s->tsin)
+        goto fail;
+
+    theta = 1.0 / 8.0 + (scale < 0 ? n4 : 0);
+    scale = sqrt(fabs(scale));
+    for(i=0;i<n4;i++) {
+        alpha = 2 * M_PI * (i + theta) / n;
+        s->tcos[i] = -cos(alpha) * scale;
+        s->tsin[i] = -sin(alpha) * scale;
+    }
+    if (ff_fft_init(&s->fft, s->nbits - 2, inverse) < 0)
+        goto fail;
+    return 0;
+ fail:
+    av_freep(&s->tcos);
+    av_freep(&s->tsin);
+    return -1;
+}
+
 /* complex multiplication: p = a * b */
 #define CMUL(pre, pim, are, aim, bre, bim) \
 {\
--- a/libavcodec/wma.c
+++ b/libavcodec/wma.c
@@ -28,41 +28,81 @@
 
 /* XXX: use same run/length optimization as mpeg decoders */
 //FIXME maybe split decode / encode or pass flag
-static void init_coef_vlc(VLC *vlc,
-                          uint16_t **prun_table, uint16_t **plevel_table, uint16_t **pint_table,
+static void init_coef_vlc(VLC *vlc, uint16_t **prun_table,
+                          uint16_t **plevel_table, uint16_t **pint_table,
                           const CoefVLCTable *vlc_table)
 {
     int n = vlc_table->n;
-    const uint8_t *table_bits = vlc_table->huffbits;
-    const uint32_t *table_codes = vlc_table->huffcodes;
+    const uint8_t  *table_bits   = vlc_table->huffbits;
+    const uint32_t *table_codes  = vlc_table->huffcodes;
     const uint16_t *levels_table = vlc_table->levels;
     uint16_t *run_table, *level_table, *int_table;
     int i, l, j, k, level;
 
     init_vlc(vlc, VLCBITS, n, table_bits, 1, 1, table_codes, 4, 4, 0);
 
-    run_table = av_malloc(n * sizeof(uint16_t));
+    run_table   = av_malloc(n * sizeof(uint16_t));
     level_table = av_malloc(n * sizeof(uint16_t));
-    int_table = av_malloc(n * sizeof(uint16_t));
+    int_table   = av_malloc(n * sizeof(uint16_t));
     i = 2;
     level = 1;
     k = 0;
     while (i < n) {
-        int_table[k]= i;
+        int_table[k] = i;
         l = levels_table[k++];
-        for(j=0;j<l;j++) {
-            run_table[i] = j;
+        for (j = 0; j < l; j++) {
+            run_table[i]   = j;
             level_table[i] = level;
             i++;
         }
         level++;
     }
-    *prun_table = run_table;
+    *prun_table   = run_table;
     *plevel_table = level_table;
-    *pint_table= int_table;
+    *pint_table   = int_table;
 }
 
-int ff_wma_init(AVCodecContext * avctx, int flags2)
+/**
+ *@brief Get the samples per frame for this stream.
+ *@param sample_rate output sample_rate
+ *@param version wma version
+ *@param decode_flags codec compression features
+ *@return log2 of the number of output samples per frame
+ */
+int av_cold ff_wma_get_frame_len_bits(int sample_rate, int version,
+                                      unsigned int decode_flags)
+{
+
+    int frame_len_bits;
+
+    if (sample_rate <= 16000) {
+        frame_len_bits = 9;
+    } else if (sample_rate <= 22050 ||
+             (sample_rate <= 32000 && version == 1)) {
+        frame_len_bits = 10;
+    } else if (sample_rate <= 48000) {
+        frame_len_bits = 11;
+    } else if (sample_rate <= 96000) {
+        frame_len_bits = 12;
+    } else {
+        frame_len_bits = 13;
+    }
+
+    if (version == 3) {
+        int tmp = decode_flags & 0x6;
+        if (tmp == 0x2) {
+            ++frame_len_bits;
+        } else if (tmp == 0x4) {
+            --frame_len_bits;
+        } else if (tmp == 0x6) {
+            frame_len_bits -= 2;
+        }
+    }
+
+    return frame_len_bits;
+}
+
+int ff_wma_init(AVCodecContext *avctx, int flags2)
 {
     WMACodecContext *s = avctx->priv_data;
     int i;
@@ -71,14 +111,14 @@
     int sample_rate1;
     int coef_vlc_table;
 
-    if(   avctx->sample_rate<=0 || avctx->sample_rate>50000
-       || avctx->channels<=0 || avctx->channels>8
-       || avctx->bit_rate<=0)
+    if (   avctx->sample_rate <= 0 || avctx->sample_rate > 50000
+        || avctx->channels    <= 0 || avctx->channels    > 8
+        || avctx->bit_rate    <= 0)
         return -1;
 
     s->sample_rate = avctx->sample_rate;
     s->nb_channels = avctx->channels;
-    s->bit_rate = avctx->bit_rate;
+    s->bit_rate    = avctx->bit_rate;
     s->block_align = avctx->block_align;
 
     dsputil_init(&s->dsp, avctx);
@@ -90,14 +130,8 @@
     }
 
     /* compute MDCT block size */
-    if (s->sample_rate <= 16000) {
-        s->frame_len_bits = 9;
-    } else if (s->sample_rate <= 22050 ||
-               (s->sample_rate <= 32000 && s->version == 1)) {
-        s->frame_len_bits = 10;
-    } else {
-        s->frame_len_bits = 11;
-    }
+    s->frame_len_bits = ff_wma_get_frame_len_bits(s->sample_rate, s->version, 0);
+
     s->frame_len = 1 << s->frame_len_bits;
     if (s->use_variable_block_len) {
         int nb_max, nb;
@@ -119,16 +153,17 @@
     /* if version 2, then the rates are normalized */
     sample_rate1 = s->sample_rate;
     if (s->version == 2) {
-        if (sample_rate1 >= 44100)
+        if (sample_rate1 >= 44100) {
             sample_rate1 = 44100;
-        else if (sample_rate1 >= 22050)
+        } else if (sample_rate1 >= 22050) {
             sample_rate1 = 22050;
-        else if (sample_rate1 >= 16000)
+        } else if (sample_rate1 >= 16000) {
             sample_rate1 = 16000;
-        else if (sample_rate1 >= 11025)
+        } else if (sample_rate1 >= 11025) {
             sample_rate1 = 11025;
-        else if (sample_rate1 >= 8000)
+        } else if (sample_rate1 >= 8000) {
             sample_rate1 = 8000;
+        }
     }
 
     bps = (float)s->bit_rate / (float)(s->nb_channels * s->sample_rate);
@@ -140,22 +175,25 @@
     if (s->nb_channels == 2)
         bps1 = bps * 1.6;
     if (sample_rate1 == 44100) {
-        if (bps1 >= 0.61)
+        if (bps1 >= 0.61) {
             s->use_noise_coding = 0;
-        else
+        } else {
             high_freq = high_freq * 0.4;
+        }
     } else if (sample_rate1 == 22050) {
-        if (bps1 >= 1.16)
+        if (bps1 >= 1.16) {
             s->use_noise_coding = 0;
-        else if (bps1 >= 0.72)
+        } else if (bps1 >= 0.72) {
             high_freq = high_freq * 0.7;
-        else
+        } else {
             high_freq = high_freq * 0.6;
+        }
     } else if (sample_rate1 == 16000) {
-        if (bps > 0.5)
+        if (bps > 0.5) {
             high_freq = high_freq * 0.5;
-        else
+        } else {
             high_freq = high_freq * 0.3;
+        }
     } else if (sample_rate1 == 11025) {
         high_freq = high_freq * 0.7;
     } else if (sample_rate1 == 8000) {
@@ -177,12 +215,12 @@
     }
     dprintf(s->avctx, "flags2=0x%x\n", flags2);
     dprintf(s->avctx, "version=%d channels=%d sample_rate=%d bitrate=%d block_align=%d\n",
-           s->version, s->nb_channels, s->sample_rate, s->bit_rate,
-           s->block_align);
+            s->version, s->nb_channels, s->sample_rate, s->bit_rate,
+            s->block_align);
     dprintf(s->avctx, "bps=%f bps1=%f high_freq=%f bitoffset=%d\n",
-           bps, bps1, high_freq, s->byte_offset_bits);
+            bps, bps1, high_freq, s->byte_offset_bits);
     dprintf(s->avctx, "use_noise_coding=%d use_exp_vlc=%d nb_block_sizes=%d\n",
-           s->use_noise_coding, s->use_exp_vlc, s->nb_block_sizes);
+            s->use_noise_coding, s->use_exp_vlc, s->nb_block_sizes);
 
     /* compute the scale factor band sizes for each MDCT block size */
     {
@@ -194,15 +232,15 @@
         } else {
             s->coefs_start = 0;
         }
-        for(k = 0; k < s->nb_block_sizes; k++) {
+        for (k = 0; k < s->nb_block_sizes; k++) {
             block_len = s->frame_len >> k;
 
             if (s->version == 1) {
                 lpos = 0;
-                for(i=0;i<25;i++) {
+                for (i = 0; i < 25; i++) {
                     a = wma_critical_freqs[i];
                     b = s->sample_rate;
-                    pos = ((block_len * 2 * a)  + (b >> 1)) / b;
+                    pos = ((block_len * 2 * a) + (b >> 1)) / b;
                     if (pos > block_len)
                         pos = block_len;
                     s->exponent_bands[0][i] = pos - lpos;
@@ -218,25 +256,26 @@
                 table = NULL;
                 a = s->frame_len_bits - BLOCK_MIN_BITS - k;
                 if (a < 3) {
-                    if (s->sample_rate >= 44100)
+                    if (s->sample_rate >= 44100) {
                         table = exponent_band_44100[a];
-                    else if (s->sample_rate >= 32000)
+                    } else if (s->sample_rate >= 32000) {
                         table = exponent_band_32000[a];
-                    else if (s->sample_rate >= 22050)
+                    } else if (s->sample_rate >= 22050) {
                         table = exponent_band_22050[a];
+                    }
                 }
                 if (table) {
                     n = *table++;
-                    for(i=0;i<n;i++)
+                    for (i = 0; i < n; i++)
                         s->exponent_bands[k][i] = table[i];
                     s->exponent_sizes[k] = n;
                 } else {
                     j = 0;
                     lpos = 0;
-                    for(i=0;i<25;i++) {
+                    for (i = 0; i < 25; i++) {
                         a = wma_critical_freqs[i];
                         b = s->sample_rate;
-                        pos = ((block_len * 2 * a)  + (b << 1)) / (4 * b);
+                        pos = ((block_len * 2 * a) + (b << 1)) / (4 * b);
                         pos <<= 2;
                         if (pos > block_len)
                             pos = block_len;
@@ -258,7 +297,7 @@
             n = s->exponent_sizes[k];
             j = 0;
             pos = 0;
-            for(i=0;i<n;i++) {
+            for (i = 0; i < n; i++) {
                 int start, end;
                 start = pos;
                 pos += s->exponent_bands[k][i];
@@ -273,11 +312,11 @@
             s->exponent_high_sizes[k] = j;
 #if 0
             tprintf(s->avctx, "%5d: coefs_end=%d high_band_start=%d nb_high_bands=%d: ",
-                  s->frame_len >> k,
-                  s->coefs_end[k],
-                  s->high_band_start[k],
-                  s->exponent_high_sizes[k]);
-            for(j=0;j<s->exponent_high_sizes[k];j++)
+                    s->frame_len >> k,
+                    s->coefs_end[k],
+                    s->high_band_start[k],
+                    s->exponent_high_sizes[k]);
+            for (j = 0; j < s->exponent_high_sizes[k]; j++)
                 tprintf(s->avctx, " %d", s->exponent_high_bands[k][j]);
             tprintf(s->avctx, "\n");
 #endif
@@ -287,11 +326,11 @@
 #ifdef TRACE
     {
         int i, j;
-        for(i = 0; i < s->nb_block_sizes; i++) {
+        for (i = 0; i < s->nb_block_sizes; i++) {
             tprintf(s->avctx, "%5d: n=%2d:",
-                   s->frame_len >> i,
-                   s->exponent_sizes[i]);
-            for(j=0;j<s->exponent_sizes[i];j++)
+                    s->frame_len >> i,
+                    s->exponent_sizes[i]);
+            for (j = 0; j < s->exponent_sizes[i]; j++)
                 tprintf(s->avctx, " %d", s->exponent_bands[i][j]);
             tprintf(s->avctx, "\n");
         }
@@ -299,7 +338,7 @@
 #endif
 
     /* init MDCT windows : simple sinus window */
-    for(i = 0; i < s->nb_block_sizes; i++) {
+    for (i = 0; i < s->nb_block_sizes; i++) {
         int n;
         n = 1 << (s->frame_len_bits - i);
         ff_sine_window_init(ff_sine_windows[s->frame_len_bits - i - 7], n);
@@ -311,13 +350,14 @@
     if (s->use_noise_coding) {
 
         /* init the noise generator */
-        if (s->use_exp_vlc)
+        if (s->use_exp_vlc) {
             s->noise_mult = 0.02;
-        else
+        } else {
             s->noise_mult = 0.04;
+        }
 
 #ifdef TRACE
-        for(i=0;i<NOISE_TAB_SIZE;i++)
+        for (i = 0; i < NOISE_TAB_SIZE; i++)
             s->noise_table[i] = 1.0 * s->noise_mult;
 #else
         {
@@ -325,7 +365,7 @@
             float norm;
             seed = 1;
             norm = (1.0 / (float)(1LL << 31)) * sqrt(3) * s->noise_mult;
-            for(i=0;i<NOISE_TAB_SIZE;i++) {
+            for (i = 0; i < NOISE_TAB_SIZE; i++) {
                 seed = seed * 314159 + 1;
                 s->noise_table[i] = (float)((int)seed) * norm;
             }
@@ -336,10 +376,11 @@
     /* choose the VLC tables for the coefficients */
     coef_vlc_table = 2;
     if (s->sample_rate >= 32000) {
-        if (bps1 < 0.72)
+        if (bps1 < 0.72) {
             coef_vlc_table = 0;
-        else if (bps1 < 1.16)
+        } else if (bps1 < 1.16) {
             coef_vlc_table = 1;
+        }
     }
     s->coef_vlcs[0]= &coef_vlcs[coef_vlc_table * 2    ];
     s->coef_vlcs[1]= &coef_vlcs[coef_vlc_table * 2 + 1];
@@ -351,7 +392,8 @@
     return 0;
 }
 
-int ff_wma_total_gain_to_bits(int total_gain){
+int ff_wma_total_gain_to_bits(int total_gain)
+{
          if (total_gain < 15) return 13;
     else if (total_gain < 32) return 12;
     else if (total_gain < 40) return 11;
@@ -364,7 +406,7 @@
     WMACodecContext *s = avctx->priv_data;
     int i;
 
-    for(i = 0; i < s->nb_block_sizes; i++)
+    for (i = 0; i < s->nb_block_sizes; i++)
         ff_mdct_end(&s->mdct_ctx[i]);
 
     if (s->use_exp_vlc) {
@@ -373,7 +415,7 @@
     if (s->use_noise_coding) {
         free_vlc(&s->hgain_vlc);
     }
-    for(i = 0;i < 2; i++) {
+    for (i = 0; i < 2; i++) {
         free_vlc(&s->coef_vlc[i]);
         av_free(s->run_table[i]);
         av_free(s->level_table[i]);
@@ -382,3 +424,95 @@
 
     return 0;
 }
+
+/**
+ * Decode an uncompressed coefficient.
+ * @param s codec context
+ * @return the decoded coefficient
+ */
+unsigned int ff_wma_get_large_val(GetBitContext* gb)
+{
+    /** consumes up to 34 bits */
+    int n_bits = 8;
+    /** decode length */
+    if (get_bits1(gb)) {
+        n_bits += 8;
+        if (get_bits1(gb)) {
+            n_bits += 8;
+            if (get_bits1(gb)) {
+                n_bits += 7;
+            }
+        }
+    }
+    return get_bits_long(gb, n_bits);
+}
+
+/**
+ * Decode run level compressed coefficients.
+ * @param avctx codec context
+ * @param gb bitstream reader context
+ * @param vlc vlc table for get_vlc2
+ * @param level_table level codes
+ * @param run_table run codes
+ * @param version 0 for wma1,2 1 for wmapro
+ * @param ptr output buffer
+ * @param offset offset in the output buffer
+ * @param num_coefs number of input coefficents
+ * @param block_len input buffer length (2^n)
+ * @param frame_len_bits number of bits for escaped run codes
+ * @param coef_nb_bits number of bits for escaped level codes
+ * @return 0 on success, -1 otherwise
+ */
+int ff_wma_run_level_decode(AVCodecContext* avctx, GetBitContext* gb,
+                            VLC *vlc,
+                            const uint16_t *level_table, const uint16_t *run_table,
+                            int version, WMACoef *ptr, int offset,
+                            int num_coefs, int block_len, int frame_len_bits,
+                            int coef_nb_bits)
+{
+    int code, level, sign;
+    const unsigned int coef_mask = block_len - 1;
+    for (; offset < num_coefs; offset++) {
+        code = get_vlc2(gb, vlc->table, VLCBITS, VLCMAX);
+        if (code > 1) {
+            /** normal code */
+            offset += run_table[code];
+            level = level_table[code];
+        } else if (code == 1) {
+            /** EOB */
+            break;
+        } else {
+            /** escape */
+            if (!version) {
+                level = get_bits(gb, coef_nb_bits);
+                /** NOTE: this is rather suboptimal. reading
+                    block_len_bits would be better */
+                offset += get_bits(gb, frame_len_bits);
+            } else {
+                level = ff_wma_get_large_val(gb);
+                /** escape decode */
+                if (get_bits1(gb)) {
+                    if (get_bits1(gb)) {
+                        if (get_bits1(gb)) {
+                            av_log(avctx,AV_LOG_ERROR,
+                                "broken escape sequence\n");
+                            return -1;
+                        } else
+                            offset += get_bits(gb, frame_len_bits) + 4;
+                    } else
+                        offset += get_bits(gb, 2) + 1;
+                }
+            }
+        }
+        sign = get_bits1(gb) - 1;
+        ptr[offset & coef_mask] = (level^sign) - sign;
+    }
+    /** NOTE: EOB can be omitted */
+    if (offset > num_coefs) {
+        av_log(avctx, AV_LOG_ERROR, "overflow in spectral RLE, ignoring\n");
+        return -1;
+    }
+
+    return 0;
+}
+
--- a/libavcodec/wmadec.c
+++ b/libavcodec/wmadec.c
@@ -82,20 +82,17 @@
 static int wma_decode_init(AVCodecContext * avctx)
 {
     WMACodecContext *s = avctx->priv_data;
-    int i, flags1, flags2;
+    int i, flags2;
     uint8_t *extradata;
 
     s->avctx = avctx;
 
     /* extract flag infos */
-    flags1 = 0;
     flags2 = 0;
     extradata = avctx->extradata;
     if (avctx->codec->id == CODEC_ID_WMAV1 && avctx->extradata_size >= 4) {
-        flags1 = AV_RL16(extradata);
         flags2 = AV_RL16(extradata+2);
     } else if (avctx->codec->id == CODEC_ID_WMAV2 && avctx->extradata_size >= 6) {
-        flags1 = AV_RL32(extradata);
         flags2 = AV_RL16(extradata+4);
     }
 // for(i=0; i<avctx->extradata_size; i++)
@@ -243,46 +240,143 @@
                      s->block_len, lsp_coefs);
 }
 
+/** pow(10, i / 16.0) for i in -60..95 */
+static const float pow_tab[] = {
+    1.7782794100389e-04, 2.0535250264571e-04,
+    2.3713737056617e-04, 2.7384196342644e-04,
+    3.1622776601684e-04, 3.6517412725484e-04,
+    4.2169650342858e-04, 4.8696752516586e-04,
+    5.6234132519035e-04, 6.4938163157621e-04,
+    7.4989420933246e-04, 8.6596432336006e-04,
+    1.0000000000000e-03, 1.1547819846895e-03,
+    1.3335214321633e-03, 1.5399265260595e-03,
+    1.7782794100389e-03, 2.0535250264571e-03,
+    2.3713737056617e-03, 2.7384196342644e-03,
+    3.1622776601684e-03, 3.6517412725484e-03,
+    4.2169650342858e-03, 4.8696752516586e-03,
+    5.6234132519035e-03, 6.4938163157621e-03,
+    7.4989420933246e-03, 8.6596432336006e-03,
+    1.0000000000000e-02, 1.1547819846895e-02,
+    1.3335214321633e-02, 1.5399265260595e-02,
+    1.7782794100389e-02, 2.0535250264571e-02,
+    2.3713737056617e-02, 2.7384196342644e-02,
+    3.1622776601684e-02, 3.6517412725484e-02,
+    4.2169650342858e-02, 4.8696752516586e-02,
+    5.6234132519035e-02, 6.4938163157621e-02,
+    7.4989420933246e-02, 8.6596432336007e-02,
+    1.0000000000000e-01, 1.1547819846895e-01,
+    1.3335214321633e-01, 1.5399265260595e-01,
+    1.7782794100389e-01, 2.0535250264571e-01,
+    2.3713737056617e-01, 2.7384196342644e-01,
+    3.1622776601684e-01, 3.6517412725484e-01,
+    4.2169650342858e-01, 4.8696752516586e-01,
+    5.6234132519035e-01, 6.4938163157621e-01,
+    7.4989420933246e-01, 8.6596432336007e-01,
+    1.0000000000000e+00, 1.1547819846895e+00,
+    1.3335214321633e+00, 1.5399265260595e+00,
+    1.7782794100389e+00, 2.0535250264571e+00,
+    2.3713737056617e+00, 2.7384196342644e+00,
+    3.1622776601684e+00, 3.6517412725484e+00,
+    4.2169650342858e+00, 4.8696752516586e+00,
+    5.6234132519035e+00, 6.4938163157621e+00,
+    7.4989420933246e+00, 8.6596432336007e+00,
+    1.0000000000000e+01, 1.1547819846895e+01,
+    1.3335214321633e+01, 1.5399265260595e+01,
+    1.7782794100389e+01, 2.0535250264571e+01,
+    2.3713737056617e+01, 2.7384196342644e+01,
+    3.1622776601684e+01, 3.6517412725484e+01,
+    4.2169650342858e+01, 4.8696752516586e+01,
+    5.6234132519035e+01, 6.4938163157621e+01,
+    7.4989420933246e+01, 8.6596432336007e+01,
+    1.0000000000000e+02, 1.1547819846895e+02,
+    1.3335214321633e+02, 1.5399265260595e+02,
+    1.7782794100389e+02, 2.0535250264571e+02,
+    2.3713737056617e+02, 2.7384196342644e+02,
+    3.1622776601684e+02, 3.6517412725484e+02,
+    4.2169650342858e+02, 4.8696752516586e+02,
+    5.6234132519035e+02, 6.4938163157621e+02,
+    7.4989420933246e+02, 8.6596432336007e+02,
+    1.0000000000000e+03, 1.1547819846895e+03,
+    1.3335214321633e+03, 1.5399265260595e+03,
+    1.7782794100389e+03, 2.0535250264571e+03,
+    2.3713737056617e+03, 2.7384196342644e+03,
+    3.1622776601684e+03, 3.6517412725484e+03,
+    4.2169650342858e+03, 4.8696752516586e+03,
+    5.6234132519035e+03, 6.4938163157621e+03,
+    7.4989420933246e+03, 8.6596432336007e+03,
+    1.0000000000000e+04, 1.1547819846895e+04,
+    1.3335214321633e+04, 1.5399265260595e+04,
+    1.7782794100389e+04, 2.0535250264571e+04,
+    2.3713737056617e+04, 2.7384196342644e+04,
+    3.1622776601684e+04, 3.6517412725484e+04,
+    4.2169650342858e+04, 4.8696752516586e+04,
+    5.6234132519035e+04, 6.4938163157621e+04,
+    7.4989420933246e+04, 8.6596432336007e+04,
+    1.0000000000000e+05, 1.1547819846895e+05,
+    1.3335214321633e+05, 1.5399265260595e+05,
+    1.7782794100389e+05, 2.0535250264571e+05,
+    2.3713737056617e+05, 2.7384196342644e+05,
+    3.1622776601684e+05, 3.6517412725484e+05,
+    4.2169650342858e+05, 4.8696752516586e+05,
+    5.6234132519035e+05, 6.4938163157621e+05,
+    7.4989420933246e+05, 8.6596432336007e+05,
+};
+
 /**
  * decode exponents coded with VLC codes
  */
 static int decode_exp_vlc(WMACodecContext *s, int ch)
 {
     int last_exp, n, code;
-    const uint16_t *ptr, *band_ptr;
-    float v, *q, max_scale, *q_end;
+    const uint16_t *ptr;
+    float v, max_scale;
+    uint32_t *q, *q_end, iv;
+    const float *ptab = pow_tab + 60;
+    const uint32_t *iptab = (const uint32_t*)ptab;
 
-    band_ptr = s->exponent_bands[s->frame_len_bits - s->block_len_bits];
-    ptr = band_ptr;
-    q = s->exponents[ch];
+    ptr = s->exponent_bands[s->frame_len_bits - s->block_len_bits];
+    q = (uint32_t *)s->exponents[ch];
     q_end = q + s->block_len;
     max_scale = 0;
     if (s->version == 1) {
         last_exp = get_bits(&s->gb, 5) + 10;
-        /* XXX: use a table */
-        v = pow(10, last_exp * (1.0 / 16.0));
+        v = ptab[last_exp];
+        iv = iptab[last_exp];
         max_scale = v;
         n = *ptr++;
-        do {
-            *q++ = v;
-        } while (--n);
+        switch (n & 3) do {
+        case 0: *q++ = iv;
+        case 3: *q++ = iv;
+        case 2: *q++ = iv;
+        case 1: *q++ = iv;
+        } while ((n -= 4) > 0);
     }else
         last_exp = 36;
 
     while (q < q_end) {
         code = get_vlc2(&s->gb, s->exp_vlc.table, EXPVLCBITS, EXPMAX);
-        if (code < 0)
+        if (code < 0){
+            av_log(s->avctx, AV_LOG_ERROR, "Exponent vlc invalid\n");
             return -1;
+        }
         /* NOTE: this offset is the same as MPEG4 AAC ! */
         last_exp += code - 60;
-        /* XXX: use a table */
-        v = pow(10, last_exp * (1.0 / 16.0));
+        if ((unsigned)last_exp + 60 > FF_ARRAY_ELEMS(pow_tab)) {
+            av_log(s->avctx, AV_LOG_ERROR, "Exponent out of range: %d\n",
+                   last_exp);
+            return -1;
+        }
+        v = ptab[last_exp];
+        iv = iptab[last_exp];
         if (v > max_scale)
             max_scale = v;
         n = *ptr++;
-        do {
-            *q++ = v;
-        } while (--n);
+        switch (n & 3) do {
+        case 0: *q++ = iv;
+        case 3: *q++ = iv;
+        case 2: *q++ = iv;
+        case 1: *q++ = iv;
+        } while ((n -= 4) > 0);
     }
     s->max_exponent[ch] = max_scale;
     return 0;
@@ -305,16 +399,16 @@
         block_len = s->block_len;
         bsize = s->frame_len_bits - s->block_len_bits;
 
-        s->dsp.vector_fmul_add_add(out, in, s->windows[bsize],
-                                   out, 0, block_len, 1);
+        s->dsp.vector_fmul_add(out, in, s->windows[bsize],
+                               out, block_len);
 
     } else {
         block_len = 1 << s->prev_block_len_bits;
         n = (s->block_len - block_len) / 2;
         bsize = s->frame_len_bits - s->prev_block_len_bits;
 
-        s->dsp.vector_fmul_add_add(out+n, in+n, s->windows[bsize],
-                                   out+n, 0, block_len, 1);
+        s->dsp.vector_fmul_add(out+n, in+n, s->windows[bsize],
+                               out+n, block_len);
 
         memcpy(out+n+block_len, in+n+block_len, n*sizeof(float));
     }
@@ -349,7 +443,7 @@
  */
 static int wma_decode_block(WMACodecContext *s)
 {
-    int n, v, a, ch, code, bsize;
+    int n, v, a, ch, bsize;
     int coef_nb_bits, total_gain;
     int nb_coefs[MAX_CHANNELS];
     float mdct_norm;
@@ -365,12 +459,16 @@
         if (s->reset_block_lengths) {
             s->reset_block_lengths = 0;
             v = get_bits(&s->gb, n);
-            if (v >= s->nb_block_sizes)
+            if (v >= s->nb_block_sizes){
+                av_log(s->avctx, AV_LOG_ERROR, "prev_block_len_bits %d out of range\n", s->frame_len_bits - v);
                 return -1;
+            }
             s->prev_block_len_bits = s->frame_len_bits - v;
             v = get_bits(&s->gb, n);
-            if (v >= s->nb_block_sizes)
+            if (v >= s->nb_block_sizes){
+                av_log(s->avctx, AV_LOG_ERROR, "block_len_bits %d out of range\n", s->frame_len_bits - v);
                 return -1;
+            }
             s->block_len_bits = s->frame_len_bits - v;
         } else {
             /* update block lengths */
@@ -378,8 +476,10 @@
             s->block_len_bits = s->next_block_len_bits;
         }
         v = get_bits(&s->gb, n);
-        if (v >= s->nb_block_sizes)
+        if (v >= s->nb_block_sizes){
+            av_log(s->avctx, AV_LOG_ERROR, "next_block_len_bits %d out of range\n", s->frame_len_bits - v);
             return -1;
+        }
         s->next_block_len_bits = s->frame_len_bits - v;
     } else {
         /* fixed block len */
@@ -390,8 +490,10 @@
 
     /* now check if the block length is coherent with the frame length */
     s->block_len = 1 << s->block_len_bits;
-    if ((s->block_pos + s->block_len) > s->frame_len)
+    if ((s->block_pos + s->block_len) > s->frame_len){
+        av_log(s->avctx, AV_LOG_ERROR, "frame_len overflow\n");
         return -1;
+    }
 
     if (s->nb_channels == 2) {
         s->ms_stereo = get_bits1(&s->gb);
@@ -455,8 +557,10 @@
                             val = get_bits(&s->gb, 7) - 19;
                         } else {
                             code = get_vlc2(&s->gb, s->hgain_vlc.table, HGAINVLCBITS, HGAINMAX);
-                            if (code < 0)
+                            if (code < 0){
+                                av_log(s->avctx, AV_LOG_ERROR, "hgain vlc invalid\n");
                                 return -1;
+                            }
                             val += code - 18;
                         }
                         s->high_band_values[ch][i] = val;
@@ -485,53 +589,17 @@
     /* parse spectral coefficients : just RLE encoding */
     for(ch = 0; ch < s->nb_channels; ch++) {
         if (s->channel_coded[ch]) {
-            VLC *coef_vlc;
-            int level, run, sign, tindex;
-            int16_t *ptr, *eptr;
-            const uint16_t *level_table, *run_table;
+            int tindex;
+            WMACoef* ptr = &s->coefs1[ch][0];
 
             /* special VLC tables are used for ms stereo because
                there is potentially less energy there */
             tindex = (ch == 1 && s->ms_stereo);
-            coef_vlc = &s->coef_vlc[tindex];
-            run_table = s->run_table[tindex];
-            level_table = s->level_table[tindex];
-            /* XXX: optimize */
-            ptr = &s->coefs1[ch][0];
-            eptr = ptr + nb_coefs[ch];
-            memset(ptr, 0, s->block_len * sizeof(int16_t));
-            for(;;) {
-                code = get_vlc2(&s->gb, coef_vlc->table, VLCBITS, VLCMAX);
-                if (code < 0)
-                    return -1;
-                if (code == 1) {
-                    /* EOB */
-                    break;
-                } else if (code == 0) {
-                    /* escape */
-                    level = get_bits(&s->gb, coef_nb_bits);
-                    /* NOTE: this is rather suboptimal. reading
-                       block_len_bits would be better */
-                    run = get_bits(&s->gb, s->frame_len_bits);
-                } else {
-                    /* normal code */
-                    run = run_table[code];
-                    level = level_table[code];
-                }
-                sign = get_bits1(&s->gb);
-                if (!sign)
-                    level = -level;
-                ptr += run;
-                if (ptr >= eptr)
-                {
-                    av_log(NULL, AV_LOG_ERROR, "overflow in spectral RLE, ignoring\n");
-                    break;
-                }
-                *ptr++ = level;
-                /* NOTE: EOB can be omitted */
-                if (ptr >= eptr)
-                    break;
-            }
+            memset(ptr, 0, s->block_len * sizeof(WMACoef));
+            ff_wma_run_level_decode(s->avctx, &s->gb, &s->coef_vlc[tindex],
+                  s->level_table[tindex], s->run_table[tindex],
+                  0, ptr, 0, nb_coefs[ch],
+                  s->block_len, s->frame_len_bits, coef_nb_bits);
         }
         if (s->version == 1 && s->nb_channels >= 2) {
             align_get_bits(&s->gb);
@@ -550,7 +618,7 @@
     /* finally compute the MDCT coefficients */
     for(ch = 0; ch < s->nb_channels; ch++) {
         if (s->channel_coded[ch]) {
-            int16_t *coefs1;
+            WMACoef *coefs1;
             float *coefs, *exponents, mult, mult1, noise;
             int i, j, n, n1, last_high_band, esize;
             float exp_power[HIGH_BAND_MAX_SIZE];
@@ -574,7 +642,7 @@
 
                 /* compute power of high bands */
                 exponents = s->exponents[ch] +
-                    (s->high_band_start[bsize]<<bsize);
+                    (s->high_band_start[bsize]<<bsize>>esize);
                 last_high_band = 0; /* avoid warning */
                 for(j=0;j<n1;j++) {
                     n = s->exponent_high_bands[s->frame_len_bits -
@@ -590,11 +658,11 @@
                         last_high_band = j;
                         tprintf(s->avctx, "%d: power=%f (%d)\n", j, exp_power[j], n);
                     }
-                    exponents += n<<bsize;
+                    exponents += n<<bsize>>esize;
                 }
 
                 /* main freqs and high freqs */
-                exponents = s->exponents[ch] + (s->coefs_start<<bsize);
+                exponents = s->exponents[ch] + (s->coefs_start<<bsize>>esize);
                 for(j=-1;j<n1;j++) {
                     if (j < 0) {
                         n = s->high_band_start[bsize] -
@@ -616,7 +684,7 @@
                             *coefs++ =  noise *
                                 exponents[i<<bsize>>esize] * mult1;
                         }
-                        exponents += n<<bsize;
+                        exponents += n<<bsize>>esize;
                     } else {
                         /* coded values + small noise */
                         for(i = 0;i < n; i++) {
@@ -625,7 +693,7 @@
                             *coefs++ = ((*coefs1++) + noise) *
                                 exponents[i<<bsize>>esize] * mult;
                         }
-                        exponents += n<<bsize;
+                        exponents += n<<bsize>>esize;
                     }
                 }
 
@@ -661,9 +729,6 @@
 #endif
 
     if (s->ms_stereo && s->channel_coded[1]) {
-        float a, b;
-        int i;
-
         /* nominal case for ms stereo: we do it before mdct */
         /* no need to optimize this case because it should almost
            never happen */
@@ -673,19 +738,13 @@
             s->channel_coded[0] = 1;
         }
 
-        for(i = 0; i < s->block_len; i++) {
-            a = s->coefs[0][i];
-            b = s->coefs[1][i];
-            s->coefs[0][i] = a + b;
-            s->coefs[1][i] = a - b;
-        }
+        s->dsp.butterflies_float(s->coefs[0], s->coefs[1], s->block_len);
     }
 
 next:
     for(ch = 0; ch < s->nb_channels; ch++) {
-        int n4, index, n;
+        int n4, index;
 
-        n = s->block_len;
         n4 = s->block_len / 2;
         if(s->channel_coded[ch]){
             ff_imdct_calc(&s->mdct_ctx[bsize], s->output, s->coefs[ch]);
@@ -833,6 +892,7 @@
         pos >>= 3;
         len = buf_size - pos;
         if (len > MAX_CODED_SUPERFRAME_SIZE || len < 0) {
+            av_log(s->avctx, AV_LOG_ERROR, "len %d invalid\n", len);
             goto fail;
         }
         s->last_superframe_len = len;
--- a/libavcodec/wmaenc.c
+++ b/libavcodec/wmaenc.c
@@ -186,7 +186,7 @@
 
     for(ch = 0; ch < s->nb_channels; ch++) {
         if (s->channel_coded[ch]) {
-            int16_t *coefs1;
+            WMACoef *coefs1;
             float *coefs, *exponents, mult;
             int i, n;
 
@@ -264,7 +264,7 @@
     for(ch = 0; ch < s->nb_channels; ch++) {
         if (s->channel_coded[ch]) {
             int run, tindex;
-            int16_t *ptr, *eptr;
+            WMACoef *ptr, *eptr;
             tindex = (ch == 1 && s->ms_stereo);
             ptr = &s->coefs1[ch][0];
             eptr = ptr + nb_coefs[ch];
@@ -392,7 +392,7 @@
     encode_init,
     encode_superframe,
     ff_wma_end,
-    .sample_fmts = (enum SampleFormat[]){SAMPLE_FMT_S16,SAMPLE_FMT_NONE},
+    .sample_fmts = (const enum SampleFormat[]){SAMPLE_FMT_S16,SAMPLE_FMT_NONE},
     .long_name = NULL_IF_CONFIG_SMALL("Windows Media Audio 1"),
 };
 
@@ -405,6 +405,6 @@
     encode_init,
     encode_superframe,
     ff_wma_end,
-    .sample_fmts = (enum SampleFormat[]){SAMPLE_FMT_S16,SAMPLE_FMT_NONE},
+    .sample_fmts = (const enum SampleFormat[]){SAMPLE_FMT_S16,SAMPLE_FMT_NONE},
     .long_name = NULL_IF_CONFIG_SMALL("Windows Media Audio 2"),
 };
--- a/libavcodec/wma.h
+++ b/libavcodec/wma.h
@@ -50,6 +50,8 @@
 #define VLCBITS 9
 #define VLCMAX ((22+VLCBITS-1)/VLCBITS)
 
+typedef float WMACoef;          ///< type for decoded coefficients, int16_t would be enough for wma 1/2
+
 typedef struct CoefVLCTable {
     int n;                      ///< total number of codes
     int max_level;
@@ -110,7 +112,7 @@
     int exponents_bsize[MAX_CHANNELS];      ///< log2 ratio frame/exp. length
     DECLARE_ALIGNED_16(float, exponents[MAX_CHANNELS][BLOCK_MAX_SIZE]);
     float max_exponent[MAX_CHANNELS];
-    int16_t coefs1[MAX_CHANNELS][BLOCK_MAX_SIZE];
+    WMACoef coefs1[MAX_CHANNELS][BLOCK_MAX_SIZE];
     DECLARE_ALIGNED_16(float, coefs[MAX_CHANNELS][BLOCK_MAX_SIZE]);
     DECLARE_ALIGNED_16(FFTSample, output[BLOCK_MAX_SIZE * 2]);
     MDCTContext mdct_ctx[BLOCK_NB_SIZES];
@@ -142,8 +144,17 @@
 extern const uint32_t ff_wma_scale_huffcodes[121];
 extern const uint8_t ff_wma_scale_huffbits[121];
 
+int av_cold ff_wma_get_frame_len_bits(int sample_rate, int version,
+                                      unsigned int decode_flags);
 int ff_wma_init(AVCodecContext * avctx, int flags2);
 int ff_wma_total_gain_to_bits(int total_gain);
 int ff_wma_end(AVCodecContext *avctx);
+unsigned int ff_wma_get_large_val(GetBitContext* gb);
+int ff_wma_run_level_decode(AVCodecContext* avctx, GetBitContext* gb,
+                            VLC *vlc,
+                            const uint16_t *level_table, const uint16_t *run_table,
+                            int version, WMACoef *ptr, int offset,
+                            int num_coefs, int block_len, int frame_len_bits,
+                            int coef_nb_bits);
 
 #endif /* AVCODEC_WMA_H */
--- a/libavcodec/wmaprodata.h
+++ b/libavcodec/wmaprodata.h
@@ -0,0 +1,604 @@
+/*
+ * WMA 9/3/PRO compatible decoder
+ * Copyright (c) 2007 Baptiste Coudurier, Benjamin Larsson, Ulion
+ * Copyright (c) 2008 - 2009 Sascha Sommer
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file  libavcodec/wmaprodata.h
+ * @brief tables for wmapro decoding
+ */
+
+#ifndef AVCODEC_WMAPRODATA_H
+#define AVCODEC_WMAPRODATA_H
+
+#include <stddef.h>
+#include <stdint.h>
+
+/**
+ * @brief frequencies to divide the frequency spectrum into scale factor bands
+ */
+static const uint16_t critical_freq[] = {
+     100,   200,    300,    400,    510,    630,    770,
+     920,  1080,   1270,   1480,   1720,   2000,   2320,
+    2700,  3150,   3700,   4400,   5300,   6400,   7700,
+    9500, 12000,  15500,  20675,  28575,  41375,  63875,
+};
+
+
+/**
+ * @name Huffman tables for DPCM-coded scale factors
+ * @{
+ */
+#define HUFF_SCALE_SIZE    121
+#define HUFF_SCALE_MAXBITS  19
+static const uint16_t scale_huffcodes[HUFF_SCALE_SIZE] = {
+    0xE639, 0xE6C2, 0xE6C1, 0xE6C0, 0xE63F, 0xE63E, 0xE63D, 0xE63C,
+    0xE63B, 0xE63A, 0xE638, 0xE637, 0xE636, 0xE635, 0xE634, 0xE632,
+    0xE633, 0xE620, 0x737B, 0xE610, 0xE611, 0xE612, 0xE613, 0xE614,
+    0xE615, 0xE616, 0xE617, 0xE618, 0xE619, 0xE61A, 0xE61B, 0xE61C,
+    0xE61D, 0xE61E, 0xE61F, 0xE6C3, 0xE621, 0xE622, 0xE623, 0xE624,
+    0xE625, 0xE626, 0xE627, 0xE628, 0xE629, 0xE62A, 0xE62B, 0xE62C,
+    0xE62D, 0xE62E, 0xE62F, 0xE630, 0xE631, 0x1CDF, 0x0E60, 0x0399,
+    0x00E7, 0x001D, 0x0000, 0x0001, 0x0001, 0x0001, 0x0002, 0x0006,
+    0x0002, 0x0007, 0x0006, 0x000F, 0x0038, 0x0072, 0x039A, 0xE6C4,
+    0xE6C5, 0xE6C6, 0xE6C7, 0xE6C8, 0xE6C9, 0xE6CA, 0xE6CB, 0xE6CC,
+    0xE6CD, 0xE6CE, 0xE6CF, 0xE6D0, 0xE6D1, 0xE6D2, 0xE6D3, 0xE6D4,
+    0xE6D5, 0xE6D6, 0xE6D7, 0xE6D8, 0xE6D9, 0xE6DA, 0xE6DB, 0xE6DC,
+    0xE6DD, 0xE6DE, 0xE6DF, 0xE6E0, 0xE6E1, 0xE6E2, 0xE6E3, 0xE6E4,
+    0xE6E5, 0xE6E6, 0xE6E7, 0xE6E8, 0xE6E9, 0xE6EA, 0xE6EB, 0xE6EC,
+    0xE6ED, 0xE6EE, 0xE6EF, 0xE6F0, 0xE6F1, 0xE6F2, 0xE6F3, 0xE6F4,
+    0xE6F5,
+};
+
+static const uint8_t scale_huffbits[HUFF_SCALE_SIZE] = {
+    19, 19, 19, 19, 19, 19, 19, 19,
+    19, 19, 19, 19, 19, 19, 19, 19,
+    19, 19, 18, 19, 19, 19, 19, 19,
+    19, 19, 19, 19, 19, 19, 19, 19,
+    19, 19, 19, 19, 19, 19, 19, 19,
+    19, 19, 19, 19, 19, 19, 19, 19,
+    19, 19, 19, 19, 19, 16, 15, 13,
+    11,  8,  5,  2,  1,  3,  5,  6,
+     6,  7,  7,  7,  9, 10, 13, 19,
+    19, 19, 19, 19, 19, 19, 19, 19,
+    19, 19, 19, 19, 19, 19, 19, 19,
+    19, 19, 19, 19, 19, 19, 19, 19,
+    19, 19, 19, 19, 19, 19, 19, 19,
+    19, 19, 19, 19, 19, 19, 19, 19,
+    19, 19, 19, 19, 19, 19, 19, 19,
+    19,
+};
+/** @} */
+
+
+/**
+ * @name Huffman, run and level tables for runlevel-coded scale factors
+ * @{
+ */
+#define HUFF_SCALE_RL_SIZE    120
+#define HUFF_SCALE_RL_MAXBITS  21
+static const uint32_t scale_rl_huffcodes[HUFF_SCALE_RL_SIZE] = {
+    0x00010C, 0x000001, 0x10FE2A, 0x000003, 0x000003, 0x000001, 0x000013,
+    0x000020, 0x000029, 0x000014, 0x000016, 0x000045, 0x000049, 0x00002F,
+    0x000042, 0x00008E, 0x00008F, 0x000129, 0x000009, 0x00000D, 0x0004AC,
+    0x00002C, 0x000561, 0x0002E6, 0x00087C, 0x0002E2, 0x00095C, 0x000018,
+    0x000001, 0x000016, 0x000044, 0x00002A, 0x000007, 0x000159, 0x000143,
+    0x000128, 0x00015A, 0x00012D, 0x00002B, 0x0000A0, 0x000142, 0x00012A,
+    0x0002EF, 0x0004AF, 0x00087D, 0x004AE9, 0x0043F9, 0x000067, 0x000199,
+    0x002B05, 0x001583, 0x0021FE, 0x10FE2C, 0x000004, 0x00002E, 0x00010D,
+    0x00000A, 0x000244, 0x000017, 0x000245, 0x000011, 0x00010E, 0x00012C,
+    0x00002A, 0x00002F, 0x000121, 0x000046, 0x00087E, 0x0000BA, 0x000032,
+    0x0087F0, 0x0056DC, 0x0002EC, 0x0043FA, 0x002B6F, 0x004AE8, 0x0002B7,
+    0x10FE2B, 0x000001, 0x000051, 0x000010, 0x0002EE, 0x000B9C, 0x002576,
+    0x000198, 0x0056DD, 0x0000CD, 0x000AC0, 0x000170, 0x004AEF, 0x00002D,
+    0x0004AD, 0x0021FF, 0x0005CF, 0x002B04, 0x10FE29, 0x10FE28, 0x0002ED,
+    0x002E74, 0x021FC4, 0x004AEE, 0x010FE3, 0x087F17, 0x000000, 0x000097,
+    0x0002E3, 0x000ADA, 0x002575, 0x00173B, 0x0043FB, 0x002E75, 0x10FE2D,
+    0x0015B6, 0x00056C, 0x000057, 0x000123, 0x000120, 0x00021E, 0x000172,
+    0x0002B1,
+};
+
+static const uint8_t scale_rl_huffbits[HUFF_SCALE_RL_SIZE] = {
+     9,  2, 21,  2,  4,  5,  5,
+     6,  6,  7,  7,  7,  7,  6,
+     7,  8,  8,  9, 10, 10, 11,
+    12, 11, 12, 12, 12, 12, 11,
+     4,  5,  7,  8,  9,  9,  9,
+     9,  9,  9,  8,  8,  9,  9,
+    12, 11, 12, 15, 15, 13, 15,
+    14, 13, 14, 21,  5,  6,  9,
+    10, 10, 11, 10, 11,  9,  9,
+     6,  8,  9,  7, 12, 10, 12,
+    16, 15, 12, 15, 14, 15, 10,
+    21,  6,  7, 11, 12, 14, 14,
+    15, 15, 14, 12, 11, 15, 12,
+    11, 14, 13, 14, 21, 21, 12,
+    16, 18, 15, 17, 20,  7,  8,
+    12, 12, 14, 15, 15, 16, 21,
+    13, 11,  7,  9,  9, 10, 11,
+    10,
+};
+
+
+static const uint8_t scale_rl_run[HUFF_SCALE_RL_SIZE] = {
+     0,  0,  0,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
+    16, 17, 18, 19, 20, 21, 22, 23, 24,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
+    10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,  0,  1,  2,  3,
+     4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
+    23, 24,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
+    17, 18, 19, 20, 21, 22, 23, 24,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10,
+     0,  1,  0,  1,  0,  1,
+};
+
+static const uint8_t scale_rl_level[HUFF_SCALE_RL_SIZE] = {
+     0,  0,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
+     2,  2,  2,  2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
+     3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,
+     4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
+     4,  4,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,
+     5,  5,  5,  5,  5,  5,  5,  5,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
+     7,  7,  8,  8,  9,  9,
+};
+/** @} */
+
+
+/**
+ * @name Huffman, run and level codes for runlevel-coded coefficients
+ * @{
+ */
+#define HUFF_COEF0_SIZE    272
+#define HUFF_COEF0_MAXBITS  21
+static const uint32_t coef0_huffcodes[HUFF_COEF0_SIZE] = {
+    0x00004A, 0x00002B, 0x000000, 0x000003, 0x000006, 0x000009, 0x00000F,
+    0x000010, 0x000016, 0x000011, 0x000016, 0x000028, 0x00002F, 0x000026,
+    0x000029, 0x000045, 0x000055, 0x00005D, 0x000042, 0x00004E, 0x000051,
+    0x00005E, 0x00008D, 0x0000A8, 0x0000AD, 0x000080, 0x000096, 0x00009F,
+    0x0000AA, 0x0000BE, 0x00011C, 0x000153, 0x000158, 0x000170, 0x000104,
+    0x00010D, 0x000105, 0x000103, 0x00012F, 0x000177, 0x000175, 0x000157,
+    0x000174, 0x000225, 0x00023B, 0x00020D, 0x00021F, 0x000281, 0x00027B,
+    0x000282, 0x0002AC, 0x0002FD, 0x00044F, 0x000478, 0x00044D, 0x0002EC,
+    0x00044E, 0x000564, 0x000409, 0x00040B, 0x000501, 0x000545, 0x0004F3,
+    0x000541, 0x00043B, 0x0004F1, 0x0004F4, 0x0008FD, 0x000A94, 0x000811,
+    0x000B88, 0x000B91, 0x000B93, 0x0008EA, 0x000899, 0x000B8A, 0x000972,
+    0x0009E5, 0x000A8F, 0x000A84, 0x000A8E, 0x000A00, 0x000830, 0x0008E8,
+    0x000B95, 0x000871, 0x00083A, 0x000814, 0x000873, 0x000BFE, 0x001728,
+    0x001595, 0x001712, 0x00102A, 0x001021, 0x001729, 0x00152E, 0x0013C3,
+    0x001721, 0x001597, 0x00151B, 0x0010F2, 0x001403, 0x001703, 0x001503,
+    0x001708, 0x0013C1, 0x00170E, 0x00170C, 0x0010E1, 0x0011EA, 0x001020,
+    0x001500, 0x0017FA, 0x001704, 0x001705, 0x0017F0, 0x0017FB, 0x0021E6,
+    0x002B2D, 0x0020C6, 0x002B29, 0x002E4A, 0x0023AC, 0x001519, 0x0023F3,
+    0x002B2C, 0x0021C0, 0x0017FE, 0x0023D7, 0x0017F9, 0x0012E7, 0x0013C0,
+    0x002261, 0x0023D3, 0x002057, 0x002056, 0x0021D2, 0x0020C7, 0x0023D2,
+    0x0020EC, 0x0044C0, 0x002FE2, 0x00475B, 0x002A03, 0x002FE3, 0x0021E2,
+    0x0021D0, 0x002A31, 0x002E13, 0x002E05, 0x0047E5, 0x00000E, 0x000024,
+    0x000088, 0x0000B9, 0x00010C, 0x000224, 0x0002B3, 0x000283, 0x0002ED,
+    0x00047B, 0x00041E, 0x00043D, 0x0004F5, 0x0005FD, 0x000A92, 0x000B96,
+    0x000838, 0x000971, 0x000B83, 0x000B80, 0x000BF9, 0x0011D3, 0x0011E8,
+    0x0011D7, 0x001527, 0x0011F8, 0x001073, 0x0010F0, 0x0010E4, 0x0017F8,
+    0x001062, 0x001402, 0x0017E3, 0x00151A, 0x001077, 0x00152B, 0x00170D,
+    0x0021D3, 0x002E41, 0x0013C2, 0x000029, 0x0000A9, 0x00025D, 0x000419,
+    0x000544, 0x000B8B, 0x0009E4, 0x0011D2, 0x001526, 0x001724, 0x0012E6,
+    0x00150B, 0x0017FF, 0x002E26, 0x002E4B, 0x002B28, 0x0021E3, 0x002A14,
+    0x00475A, 0x002E12, 0x000057, 0x00023E, 0x000A90, 0x000BF0, 0x001072,
+    0x001502, 0x0023D6, 0x0020ED, 0x002A30, 0x0044C7, 0x00008C, 0x00047F,
+    0x00152A, 0x002262, 0x002E04, 0x0000A1, 0x0005F9, 0x000173, 0x000875,
+    0x000171, 0x00152D, 0x0002E3, 0x0017E2, 0x0002AD, 0x0021C1, 0x000479,
+    0x0021E7, 0x00041F, 0x005C4E, 0x000543, 0x005C4F, 0x000A91, 0x00898D,
+    0x000B97, 0x008746, 0x000970, 0x008745, 0x000B85, 0x00A856, 0x00152F,
+    0x010E8E, 0x0010E5, 0x00A857, 0x00170F, 0x021D11, 0x002A58, 0x010E8F,
+    0x002E40, 0x021D13, 0x002A59, 0x043A25, 0x002A02, 0x043A21, 0x0044C1,
+    0x087448, 0x0047E4, 0x043A20, 0x00542A, 0x087449, 0x00898C,
+};
+
+static const uint8_t coef0_huffbits[HUFF_COEF0_SIZE] = {
+     8,  7,  2,  3,  3,  4,  4,
+     5,  5,  6,  6,  6,  6,  7,
+     7,  7,  7,  7,  8,  8,  8,
+     8,  8,  8,  8,  9,  9,  9,
+     9,  9,  9,  9,  9,  9, 10,
+    10, 10, 10, 10, 10, 10, 10,
+    10, 10, 10, 11, 11, 11, 11,
+    11, 11, 11, 11, 11, 11, 11,
+    11, 11, 12, 12, 12, 12, 12,
+    12, 12, 12, 12, 12, 12, 13,
+    12, 12, 12, 12, 12, 12, 13,
+    13, 13, 13, 13, 13, 13, 12,
+    12, 13, 13, 13, 13, 13, 13,
+    13, 13, 14, 14, 13, 13, 14,
+    13, 13, 14, 14, 14, 14, 14,
+    14, 14, 14, 14, 14, 13, 14,
+    14, 14, 14, 14, 14, 14, 15,
+    14, 15, 14, 14, 14, 14, 14,
+    14, 15, 14, 14, 14, 14, 14,
+    14, 14, 15, 15, 15, 15, 14,
+    15, 15, 15, 15, 15, 15, 15,
+    15, 15, 15, 15, 15,  4,  7,
+     8,  9, 10, 10, 10, 11, 11,
+    11, 12, 12, 12, 12, 12, 12,
+    13, 13, 13, 13, 13, 13, 13,
+    13, 13, 13, 14, 14, 14, 14,
+    14, 14, 14, 14, 14, 13, 14,
+    15, 14, 14,  6,  9, 11, 12,
+    12, 12, 13, 13, 13, 13, 14,
+    14, 14, 14, 14, 14, 15, 15,
+    15, 15,  7, 10, 12, 13, 14,
+    14, 14, 15, 15, 15,  8, 11,
+    13, 14, 15,  9, 12,  9, 13,
+    10, 13, 10, 14, 11, 15, 11,
+    15, 12, 15, 12, 15, 12, 16,
+    12, 17, 13, 17, 13, 17, 13,
+    18, 14, 17, 14, 19, 14, 18,
+    14, 19, 14, 20, 15, 20, 15,
+    21, 15, 20, 16, 21, 16,
+};
+
+
+#define HUFF_COEF1_SIZE    244
+#define HUFF_COEF1_MAXBITS  22
+static const uint32_t coef1_huffcodes[HUFF_COEF1_SIZE] = {
+    0x0001E2, 0x00007F, 0x000000, 0x000002, 0x000008, 0x00000E, 0x000019,
+    0x00002F, 0x000037, 0x000060, 0x00006C, 0x000095, 0x0000C6, 0x0000F0,
+    0x00012E, 0x000189, 0x0001A5, 0x0001F8, 0x000253, 0x00030A, 0x000344,
+    0x00034D, 0x0003F2, 0x0004BD, 0x0005D7, 0x00062A, 0x00068B, 0x000693,
+    0x000797, 0x00097D, 0x000BAB, 0x000C52, 0x000C5E, 0x000D21, 0x000D20,
+    0x000F1A, 0x000FCE, 0x000FD1, 0x0012F1, 0x001759, 0x0018AC, 0x0018A7,
+    0x0018BF, 0x001A2B, 0x001E52, 0x001E50, 0x001E31, 0x001FB8, 0x0025E6,
+    0x0025E7, 0x002EB4, 0x002EB7, 0x003169, 0x00315B, 0x00317C, 0x00316C,
+    0x0034CA, 0x00348D, 0x003F40, 0x003CA2, 0x003F76, 0x004BC3, 0x004BE5,
+    0x003F73, 0x004BF8, 0x004BF9, 0x006131, 0x00628B, 0x006289, 0x0062DA,
+    0x00628A, 0x0062D4, 0x006997, 0x0062B4, 0x006918, 0x00794D, 0x007E7B,
+    0x007E87, 0x007EEA, 0x00794E, 0x00699D, 0x007967, 0x00699F, 0x0062DB,
+    0x007E7A, 0x007EEB, 0x00BAC0, 0x0097C9, 0x00C537, 0x00C5AB, 0x00D233,
+    0x00D338, 0x00BAC1, 0x00D23D, 0x012F91, 0x00D339, 0x00FDC8, 0x00D23C,
+    0x00FDDC, 0x00FDC9, 0x00FDDD, 0x00D33C, 0x000003, 0x000016, 0x00003E,
+    0x0000C3, 0x0001A1, 0x000347, 0x00062E, 0x000BAA, 0x000F2D, 0x001A2A,
+    0x001E58, 0x00309B, 0x003CA3, 0x005D6A, 0x00629A, 0x006996, 0x00794F,
+    0x007EE5, 0x00BAD7, 0x00C5AA, 0x00C5F4, 0x00FDDF, 0x00FDDE, 0x018A20,
+    0x018A6D, 0x01A67B, 0x01A464, 0x025F21, 0x01F9E2, 0x01F9E3, 0x00000A,
+    0x00003D, 0x000128, 0x0003C7, 0x000C24, 0x0018A3, 0x002EB1, 0x003CB2,
+    0x00691F, 0x007E79, 0x000013, 0x0000BB, 0x00034E, 0x000D14, 0x0025FD,
+    0x004BE7, 0x000024, 0x000188, 0x0007EF, 0x000035, 0x000308, 0x0012F2,
+    0x00005C, 0x0003F6, 0x0025E0, 0x00006D, 0x000698, 0x000096, 0x000C25,
+    0x0000C7, 0x000F1B, 0x0000F3, 0x0012FF, 0x000174, 0x001A66, 0x0001A0,
+    0x003099, 0x0001E4, 0x00316B, 0x000252, 0x003F31, 0x00030B, 0x004BE6,
+    0x000346, 0x0062FB, 0x00034F, 0x007966, 0x0003F5, 0x007E86, 0x0005D4,
+    0x00C511, 0x00062C, 0x00C5F5, 0x000692, 0x00F299, 0x000795, 0x00F298,
+    0x0007E9, 0x018A21, 0x00097E, 0x0175AD, 0x000C27, 0x01A67A, 0x000C57,
+    0x02EB59, 0x000D22, 0x0314D9, 0x000F19, 0x03F3C2, 0x000FCD, 0x0348CB,
+    0x0012F8, 0x04BE41, 0x0018A0, 0x03F3C1, 0x0018A1, 0x04BE40, 0x0018B7,
+    0x0629B0, 0x001A64, 0x0D2329, 0x001E30, 0x03F3C3, 0x001F9F, 0x0BAD62,
+    0x001F99, 0x0FCF00, 0x00309A, 0x0629B1, 0x002EB6, 0x175AC3, 0x00314C,
+    0x069195, 0x003168, 0x0BAD63, 0x00348E, 0x175AC1, 0x003F30, 0x07E781,
+    0x003F41, 0x0D2328, 0x003F42, 0x1F9E03, 0x004BC2, 0x175AC2, 0x003F74,
+    0x175AC0, 0x005D61, 0x3F3C05, 0x006130, 0x3F3C04, 0x0062B5,
+};
+
+static const uint8_t coef1_huffbits[HUFF_COEF1_SIZE] = {
+     9,  7,  2,  3,  4,  4,  5,
+     6,  6,  7,  7,  8,  8,  8,
+     9,  9,  9,  9, 10, 10, 10,
+    10, 10, 11, 11, 11, 11, 11,
+    11, 12, 12, 12, 12, 12, 12,
+    12, 12, 12, 13, 13, 13, 13,
+    13, 13, 13, 13, 13, 13, 14,
+    14, 14, 14, 14, 14, 14, 14,
+    14, 14, 14, 14, 14, 15, 15,
+    14, 15, 15, 15, 15, 15, 15,
+    15, 15, 15, 15, 15, 15, 15,
+    15, 15, 15, 15, 15, 15, 15,
+    15, 15, 16, 16, 16, 16, 16,
+    16, 16, 16, 17, 16, 16, 16,
+    16, 16, 16, 16,  3,  5,  6,
+     8,  9, 10, 11, 12, 12, 13,
+    13, 14, 14, 15, 15, 15, 15,
+    15, 16, 16, 16, 16, 16, 17,
+    17, 17, 17, 18, 17, 17,  4,
+     6,  9, 10, 12, 13, 14, 14,
+    15, 15,  5,  8, 10, 12, 14,
+    15,  6,  9, 11,  6, 10, 13,
+     7, 10, 14,  7, 11,  8, 12,
+     8, 12,  8, 13,  9, 13,  9,
+    14,  9, 14, 10, 14, 10, 15,
+    10, 15, 10, 15, 10, 15, 11,
+    16, 11, 16, 11, 16, 11, 16,
+    11, 17, 12, 17, 12, 17, 12,
+    18, 12, 18, 12, 18, 12, 18,
+    13, 19, 13, 18, 13, 19, 13,
+    19, 13, 20, 13, 18, 13, 20,
+    13, 20, 14, 19, 14, 21, 14,
+    19, 14, 20, 14, 21, 14, 19,
+    14, 20, 14, 21, 15, 21, 14,
+    21, 15, 22, 15, 22, 15,
+};
+
+
+static const uint16_t coef0_run[HUFF_COEF0_SIZE] = {
+      0,   0,   0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,
+     12,  13,  14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,
+     26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
+     40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,
+     54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,
+     68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,
+     82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,
+     96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
+    110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123,
+    124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
+    138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,   0,   1,
+      2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,
+     16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
+     30,  31,  32,  33,  34,  35,  36,  37,  38,  39,   0,   1,   2,   3,
+      4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16,  17,
+     18,  19,   0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   0,   1,
+      2,   3,   4,   0,   1,   0,   1,   0,   1,   0,   1,   0,   1,   0,
+      1,   0,   1,   0,   1,   0,   1,   0,   1,   0,   1,   0,   1,   0,
+      1,   0,   1,   0,   1,   0,   1,   0,   1,   0,   1,   0,   1,   0,
+      1,   0,   1,   0,   1,   0,
+};
+
+static const uint16_t coef0_level[HUFF_COEF0_SIZE] = {
+      0,   0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
+      1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
+      1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
+      1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
+      1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
+      1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
+      1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
+      1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
+      1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
+      1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
+      1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   2,   2,
+      2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
+      2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
+      2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   3,   3,   3,   3,
+      3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,
+      3,   3,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   5,   5,
+      5,   5,   5,   6,   6,   7,   7,   8,   8,   9,   9,  10,  10,  11,
+     11,  12,  12,  13,  13,  14,  14,  15,  15,  16,  16,  17,  17,  18,
+     18,  19,  19,  20,  20,  21,  21,  22,  22,  23,  23,  24,  24,  25,
+     25,  26,  26,  27,  27,  28,
+};
+
+
+static const uint16_t coef1_run[HUFF_COEF1_SIZE] = {
+     0,  0,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
+    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,
+    34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
+    52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69,
+    70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,
+    88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,  0,  1,  2,  3,  4,  5,
+     6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
+    24, 25, 26, 27, 28, 29,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  0,  1,
+     2,  3,  4,  5,  0,  1,  2,  0,  1,  2,  0,  1,  2,  0,  1,  0,  1,  0,
+     1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
+     1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
+     1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
+     1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
+     1,  0,  1,  0,  1,  0,  1,  0,  0,  0,
+};
+
+static const uint16_t coef1_level[HUFF_COEF1_SIZE] = {
+     0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
+     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
+     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
+     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
+     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
+     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,
+     2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
+     2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  4,  4,
+     4,  4,  4,  4,  5,  5,  5,  6,  6,  6,  7,  7,  7,  8,  8,  9,  9, 10,
+    10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19,
+    19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28,
+    28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35, 35, 36, 36, 37,
+    37, 38, 38, 39, 39, 40, 40, 41, 41, 42, 42, 43, 43, 44, 44, 45, 45, 46,
+    46, 47, 47, 48, 48, 49, 49, 50, 51, 52,
+};
+/** @} */
+
+
+/**
+ * @name Huffman and vector lookup tables for vector-coded coefficients
+ * @{
+ */
+#define HUFF_VEC4_SIZE    127
+#define HUFF_VEC4_MAXBITS  14
+static const uint16_t vec4_huffcodes[HUFF_VEC4_SIZE] = {
+    0x0019, 0x0027, 0x00F2, 0x03BA, 0x0930, 0x1267, 0x0031, 0x0030,
+    0x0097, 0x0221, 0x058B, 0x0124, 0x00EB, 0x01D4, 0x03D8, 0x0584,
+    0x0364, 0x045F, 0x0F66, 0x0931, 0x24CD, 0x002F, 0x0039, 0x00E8,
+    0x02C3, 0x078A, 0x0037, 0x0029, 0x0084, 0x01B1, 0x00ED, 0x0086,
+    0x00F9, 0x03AB, 0x01EB, 0x08BC, 0x011E, 0x00F3, 0x0220, 0x058A,
+    0x00EC, 0x008E, 0x012B, 0x01EA, 0x0119, 0x04B0, 0x04B1, 0x03B8,
+    0x0691, 0x0365, 0x01ED, 0x049A, 0x0EA9, 0x0EA8, 0x08BD, 0x24CC,
+    0x0026, 0x0035, 0x00DB, 0x02C4, 0x07B2, 0x0038, 0x002B, 0x007F,
+    0x01B3, 0x00F4, 0x0091, 0x0116, 0x03BB, 0x0215, 0x0932, 0x002D,
+    0x002A, 0x008A, 0x01DE, 0x0028, 0x0020, 0x005C, 0x0090, 0x0068,
+    0x01EE, 0x00E9, 0x008D, 0x012A, 0x0087, 0x005D, 0x0118, 0x0349,
+    0x01EF, 0x01E3, 0x08B9, 0x00F0, 0x00D3, 0x0214, 0x049B, 0x00DA,
+    0x0089, 0x0125, 0x0217, 0x012D, 0x0690, 0x0094, 0x007D, 0x011F,
+    0x007E, 0x0059, 0x0127, 0x01A5, 0x0111, 0x00F8, 0x045D, 0x03B9,
+    0x0259, 0x0580, 0x02C1, 0x01DF, 0x0585, 0x0216, 0x0163, 0x01B0,
+    0x03C4, 0x08B8, 0x078B, 0x0755, 0x0581, 0x0F67, 0x0000,
+};
+
+static const uint8_t vec4_huffbits[HUFF_VEC4_SIZE] = {
+     5,  6,  8, 10, 12, 13,  6,  6,
+     8, 10, 11,  9,  8,  9, 10, 11,
+    10, 11, 12, 12, 14,  6,  6,  8,
+    10, 11,  6,  6,  8,  9,  8,  8,
+     8, 10,  9, 12,  9,  8, 10, 11,
+     8,  8,  9,  9,  9, 11, 11, 10,
+    11, 10,  9, 11, 12, 12, 12, 14,
+     6,  6,  8, 10, 11,  6,  6,  7,
+     9,  8,  8,  9, 10, 10, 12,  6,
+     6,  8,  9,  6,  6,  7,  8,  7,
+     9,  8,  8,  9,  8,  7,  9, 10,
+     9,  9, 12,  8,  8, 10, 11,  8,
+     8,  9, 10,  9, 11,  8,  7,  9,
+     7,  7,  9,  9,  9,  8, 11, 10,
+    10, 11, 10,  9, 11, 10,  9,  9,
+    10, 12, 11, 11, 11, 12,  1,
+};
+
+
+#define HUFF_VEC2_SIZE    137
+#define HUFF_VEC2_MAXBITS  12
+static const uint16_t vec2_huffcodes[HUFF_VEC2_SIZE] = {
+    0x055, 0x01C, 0x01A, 0x02B, 0x028, 0x067, 0x08B, 0x039,
+    0x170, 0x10D, 0x2A5, 0x047, 0x464, 0x697, 0x523, 0x8CB,
+    0x01B, 0x00E, 0x000, 0x010, 0x012, 0x036, 0x048, 0x04C,
+    0x0C2, 0x09B, 0x171, 0x03B, 0x224, 0x34A, 0x2D6, 0x019,
+    0x00F, 0x002, 0x014, 0x017, 0x006, 0x05D, 0x054, 0x0C7,
+    0x0B4, 0x192, 0x10E, 0x233, 0x043, 0x02C, 0x00F, 0x013,
+    0x006, 0x02F, 0x02C, 0x068, 0x077, 0x0DF, 0x111, 0x1A4,
+    0x16A, 0x2A4, 0x027, 0x011, 0x018, 0x02D, 0x00F, 0x04A,
+    0x040, 0x097, 0x01F, 0x11B, 0x022, 0x16D, 0x066, 0x035,
+    0x005, 0x02B, 0x049, 0x009, 0x075, 0x0CB, 0x0AA, 0x187,
+    0x106, 0x08A, 0x047, 0x060, 0x06E, 0x01D, 0x074, 0x0C4,
+    0x01E, 0x118, 0x1A7, 0x038, 0x042, 0x053, 0x076, 0x0A8,
+    0x0CA, 0x082, 0x110, 0x18D, 0x12D, 0x0B9, 0x0C8, 0x0DE,
+    0x01C, 0x0AB, 0x113, 0x18C, 0x10F, 0x09A, 0x0A5, 0x0B7,
+    0x11A, 0x186, 0x1A6, 0x259, 0x153, 0x18A, 0x193, 0x020,
+    0x10C, 0x046, 0x03A, 0x107, 0x149, 0x16C, 0x2D7, 0x225,
+    0x258, 0x316, 0x696, 0x317, 0x042, 0x522, 0x290, 0x8CA,
+    0x001,
+};
+
+static const uint8_t vec2_huffbits[HUFF_VEC2_SIZE] = {
+     7,  6,  6,  6,  7,  7,  8,  9,
+     9, 10, 10, 11, 11, 11, 12, 12,
+     6,  4,  5,  5,  6,  6,  7,  8,
+     8,  9,  9, 10, 10, 10, 11,  6,
+     4,  5,  5,  6,  7,  7,  8,  8,
+     9,  9, 10, 10, 11,  6,  5,  5,
+     6,  6,  7,  7,  8,  8,  9,  9,
+    10, 10,  7,  6,  6,  6,  7,  7,
+     8,  8,  9,  9, 10, 10,  7,  6,
+     7,  7,  7,  8,  8,  8,  9,  9,
+    10,  8,  7,  7,  7,  8,  8,  8,
+     9,  9,  9,  9,  8,  8,  8,  8,
+     8,  9,  9,  9,  9,  8,  8,  8,
+     9,  9,  9,  9, 10,  9,  9,  9,
+     9,  9,  9, 10,  9,  9,  9, 10,
+    10, 11, 10, 10, 10, 10, 11, 10,
+    10, 10, 11, 10, 11, 12, 11, 12,
+     3,
+};
+
+
+#define HUFF_VEC1_SIZE    101
+#define HUFF_VEC1_MAXBITS  11
+static const uint16_t vec1_huffcodes[HUFF_VEC1_SIZE] = {
+    0x01A, 0x003, 0x017, 0x010, 0x00C, 0x009, 0x005, 0x000,
+    0x00D, 0x00A, 0x009, 0x00C, 0x00F, 0x002, 0x004, 0x007,
+    0x00B, 0x00F, 0x01C, 0x006, 0x010, 0x015, 0x01C, 0x022,
+    0x03B, 0x00E, 0x019, 0x023, 0x034, 0x036, 0x03A, 0x047,
+    0x008, 0x00A, 0x01E, 0x031, 0x037, 0x050, 0x053, 0x06B,
+    0x06F, 0x08C, 0x0E8, 0x0EA, 0x0EB, 0x016, 0x03E, 0x03F,
+    0x06C, 0x089, 0x08A, 0x0A3, 0x0A4, 0x0D4, 0x0DD, 0x0EC,
+    0x0EE, 0x11A, 0x1D2, 0x024, 0x025, 0x02E, 0x027, 0x0C2,
+    0x0C0, 0x0DA, 0x0DB, 0x111, 0x144, 0x116, 0x14A, 0x145,
+    0x1B8, 0x1AB, 0x1DA, 0x1DE, 0x1DB, 0x1DF, 0x236, 0x237,
+    0x3A6, 0x3A7, 0x04D, 0x04C, 0x05E, 0x05F, 0x183, 0x182,
+    0x186, 0x221, 0x187, 0x220, 0x22E, 0x22F, 0x296, 0x354,
+    0x297, 0x355, 0x372, 0x373, 0x016,
+};
+
+static const uint8_t vec1_huffbits[HUFF_VEC1_SIZE] = {
+     7,  6,  5,  5,  5,  5,  5,  5,
+     4,  4,  4,  4,  4,  5,  5,  5,
+     5,  5,  5,  6,  6,  6,  6,  6,
+     6,  7,  7,  7,  7,  7,  7,  7,
+     8,  8,  8,  8,  8,  8,  8,  8,
+     8,  8,  8,  8,  8,  9,  9,  9,
+     9,  9,  9,  9,  9,  9,  9,  9,
+     9,  9,  9, 10, 10, 10, 10, 10,
+    10, 10, 10, 10, 10, 10, 10, 10,
+    10, 10, 10, 10, 10, 10, 10, 10,
+    10, 10, 11, 11, 11, 11, 11, 11,
+    11, 11, 11, 11, 11, 11, 11, 11,
+    11, 11, 11, 11,  5,
+};
+
+
+static const uint16_t symbol_to_vec4[HUFF_VEC4_SIZE] = {
+        0,    1,      2,     3,     4,     5,    16,    17,    18,    19,
+       20,   32,     33,    34,    35,    48,    49,    50,    64,    65,
+       80,   256,   257,   258,   259,   260,   272,   273,   274,   275,
+      288,   289,   290,   304,   305,   320,   512,   513,   514,   515,
+      528,   529,   530,   544,   545,   560,   768,   769,   770,   784,
+      785,   800,  1024,  1025,  1040,  1280,  4096,  4097,  4098,  4099,
+     4100,  4112,  4113,  4114,  4115,  4128,  4129,  4130,  4144,  4145,
+     4160,  4352,  4353,  4354,  4355,  4368,  4369,  4370,  4384,  4385,
+     4400,  4608,  4609,  4610,  4624,  4625,  4640,  4864,  4865,  4880,
+     5120,  8192,  8193,  8194,  8195,  8208,  8209,  8210,  8224,  8225,
+     8240,  8448,  8449,  8450,  8464,  8465,  8480,  8704,  8705,  8720,
+     8960, 12288, 12289, 12290, 12304, 12305, 12320, 12544, 12545, 12560,
+    12800, 16384, 16385, 16400, 16640, 20480,     0,
+};
+
+
+static const uint8_t symbol_to_vec2[HUFF_VEC2_SIZE] = {
+      0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,
+     15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
+     30,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,  45,
+     48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  64,  65,
+     66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  80,  81,  82,  83,  84,
+     85,  86,  87,  88,  89,  90,  96,  97,  98,  99, 100, 101, 102, 103, 104,
+    105, 112, 113, 114, 115, 116, 117, 118, 119, 120, 128, 129, 130, 131, 132,
+    133, 134, 135, 144, 145, 146, 147, 148, 149, 150, 160, 161, 162, 163, 164,
+    165, 176, 177, 178, 179, 180, 192, 193, 194, 195, 208, 209, 210, 224, 225,
+    240,   0,
+};
+/** @} */
+
+
+/**
+ * @brief decorrelation matrix for multichannel streams
+ **/
+static const float default_decorrelation_matrices[] = {
+    1.000000,  0.707031, -0.707031,  0.707031,  0.707031,  0.578125,  0.707031,
+    0.410156,  0.578125, -0.707031,  0.410156,  0.578125,  0.000000, -0.816406,
+    0.500000,  0.652344,  0.500000,  0.269531,  0.500000,  0.269531, -0.500000,
+   -0.652344,  0.500000, -0.269531, -0.500000,  0.652344,  0.500000, -0.652344,
+    0.500000, -0.269531,  0.445312,  0.601562,  0.511719,  0.371094,  0.195312,
+    0.445312,  0.371094, -0.195312, -0.601562, -0.511719,  0.445312,  0.000000,
+   -0.632812,  0.000000,  0.632812,  0.445312, -0.371094, -0.195312,  0.601562,
+   -0.511719,  0.445312, -0.601562,  0.511719, -0.371094,  0.195312,  0.410156,
+    0.558594,  0.500000,  0.410156,  0.289062,  0.148438,  0.410156,  0.410156,
+    0.000000, -0.410156, -0.578125, -0.410156,  0.410156,  0.148438, -0.500000,
+   -0.410156,  0.289062,  0.558594,  0.410156, -0.148438, -0.500000,  0.410156,
+    0.289062, -0.558594,  0.410156, -0.410156,  0.000000,  0.410156, -0.578125,
+    0.410156,  0.410156, -0.558594,  0.500000, -0.410156,  0.289062, -0.148438,
+};
+
+/**
+ * @brief default decorrelation matrix offsets
+ */
+static const float * const default_decorrelation[] = {
+    NULL,
+    &default_decorrelation_matrices[0],
+    &default_decorrelation_matrices[1],
+    &default_decorrelation_matrices[5],
+    &default_decorrelation_matrices[14],
+    &default_decorrelation_matrices[30],
+    &default_decorrelation_matrices[55]
+};
+
+#endif /* AVCODEC_WMAPRODATA_H */
--- a/libavcodec/wmaprodec.c
+++ b/libavcodec/wmaprodec.c
@@ -0,0 +1,1576 @@
+/*
+ * Wmapro compatible decoder
+ * Copyright (c) 2007 Baptiste Coudurier, Benjamin Larsson, Ulion
+ * Copyright (c) 2008 - 2009 Sascha Sommer, Benjamin Larsson
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file  libavcodec/wmaprodec.c
+ * @brief wmapro decoder implementation
+ * Wmapro is an MDCT based codec comparable to wma standard or AAC.
+ * The decoding therefore consists of the following steps:
+ * - bitstream decoding
+ * - reconstruction of per-channel data
+ * - rescaling and inverse quantization
+ * - IMDCT
+ * - windowing and overlapp-add
+ *
+ * The compressed wmapro bitstream is split into individual packets.
+ * Every such packet contains one or more wma frames.
+ * The compressed frames may have a variable length and frames may
+ * cross packet boundaries.
+ * Common to all wmapro frames is the number of samples that are stored in
+ * a frame.
+ * The number of samples and a few other decode flags are stored
+ * as extradata that has to be passed to the decoder.
+ *
+ * The wmapro frames themselves are again split into a variable number of
+ * subframes. Every subframe contains the data for 2^N time domain samples
+ * where N varies between 7 and 12.
+ *
+ * Example wmapro bitstream (in samples):
+ *
+ * ||   packet 0           || packet 1 || packet 2      packets
+ * ---------------------------------------------------
+ * || frame 0      || frame 1       || frame 2    ||    frames
+ * ---------------------------------------------------
+ * ||   |      |   ||   |   |   |   ||            ||    subframes of channel 0
+ * ---------------------------------------------------
+ * ||      |   |   ||   |   |   |   ||            ||    subframes of channel 1
+ * ---------------------------------------------------
+ *
+ * The frame layouts for the individual channels of a wma frame does not need
+ * to be the same.
+ *
+ * However, if the offsets and lengths of several subframes of a frame are the
+ * same, the subframes of the channels can be grouped.
+ * Every group may then use special coding techniques like M/S stereo coding
+ * to improve the compression ratio. These channel transformations do not
+ * need to be applied to a whole subframe. Instead, they can also work on
+ * individual scale factor bands (see below).
+ * The coefficients that carry the audio signal in the frequency domain
+ * are transmitted as huffman-coded vectors with 4, 2 and 1 elements.
+ * In addition to that, the encoder can switch to a runlevel coding scheme
+ * by transmitting subframe_length / 128 zero coefficients.
+ *
+ * Before the audio signal can be converted to the time domain, the
+ * coefficients have to be rescaled and inverse quantized.
+ * A subframe is therefore split into several scale factor bands that get
+ * scaled individually.
+ * Scale factors are submitted for every frame but they might be shared
+ * between the subframes of a channel. Scale factors are initially DPCM-coded.
+ * Once scale factors are shared, the differences are transmitted as runlevel
+ * codes.
+ * Every subframe length and offset combination in the frame layout shares a
+ * common quantization factor that can be adjusted for every channel by a
+ * modifier.
+ * After the inverse quantization, the coefficients get processed by an IMDCT.
+ * The resulting values are then windowed with a sine window and the first half
+ * of the values are added to the second half of the output from the previous
+ * subframe in order to reconstruct the output samples.
+ */
+
+#include "avcodec.h"
+#include "internal.h"
+#include "bitstream.h"
+#include "wmaprodata.h"
+#include "dsputil.h"
+#include "wma.h"
+
+/** current decoder limitations */
+#define WMAPRO_MAX_CHANNELS    8                             ///< max number of handled channels
+#define MAX_SUBFRAMES  32                                    ///< max number of subframes per channel
+#define MAX_BANDS      29                                    ///< max number of scale factor bands
+#define MAX_FRAMESIZE  32768                                 ///< maximum compressed frame size
+
+#define WMAPRO_BLOCK_MAX_BITS 12                                           ///< log2 of max block size
+#define WMAPRO_BLOCK_MAX_SIZE (1 << WMAPRO_BLOCK_MAX_BITS)                 ///< maximum block size
+#define WMAPRO_BLOCK_SIZES    (WMAPRO_BLOCK_MAX_BITS - BLOCK_MIN_BITS + 1) ///< possible block sizes
+
+
+#define VLCBITS            9
+#define SCALEVLCBITS       8
+#define VEC4MAXDEPTH    ((HUFF_VEC4_MAXBITS+VLCBITS-1)/VLCBITS)
+#define VEC2MAXDEPTH    ((HUFF_VEC2_MAXBITS+VLCBITS-1)/VLCBITS)
+#define VEC1MAXDEPTH    ((HUFF_VEC1_MAXBITS+VLCBITS-1)/VLCBITS)
+#define SCALEMAXDEPTH   ((HUFF_SCALE_MAXBITS+SCALEVLCBITS-1)/SCALEVLCBITS)
+#define SCALERLMAXDEPTH ((HUFF_SCALE_RL_MAXBITS+VLCBITS-1)/VLCBITS)
+
+static VLC              sf_vlc;           ///< scale factor DPCM vlc
+static VLC              sf_rl_vlc;        ///< scale factor run length vlc
+static VLC              vec4_vlc;         ///< 4 coefficients per symbol
+static VLC              vec2_vlc;         ///< 2 coefficients per symbol
+static VLC              vec1_vlc;         ///< 1 coefficient per symbol
+static VLC              coef_vlc[2];      ///< coefficient run length vlc codes
+static float            sin64[33];        ///< sinus table for decorrelation
+
+/**
+ * @brief frame specific decoder context for a single channel
+ */
+typedef struct {
+    int16_t  prev_block_len;                          ///< length of the previous block
+    uint8_t  transmit_coefs;
+    uint8_t  num_subframes;
+    uint16_t subframe_len[MAX_SUBFRAMES];             ///< subframe length in samples
+    uint16_t subframe_offset[MAX_SUBFRAMES];          ///< subframe positions in the current frame
+    uint8_t  cur_subframe;                            ///< current subframe number
+    uint16_t decoded_samples;                         ///< number of already processed samples
+    uint8_t  grouped;                                 ///< channel is part of a group
+    int      quant_step;                              ///< quantization step for the current subframe
+    int8_t   reuse_sf;                                ///< share scale factors between subframes
+    int8_t   scale_factor_step;                       ///< scaling step for the current subframe
+    int      max_scale_factor;                        ///< maximum scale factor for the current subframe
+    int      saved_scale_factors[2][MAX_BANDS];       ///< resampled and (previously) transmitted scale factor values
+    int8_t   scale_factor_idx;                        ///< index for the transmitted scale factor values (used for resampling)
+    int*     scale_factors;                           ///< pointer to the scale factor values used for decoding
+    uint8_t  table_idx;                               ///< index in sf_offsets for the scale factor reference block
+    float*   coeffs;                                  ///< pointer to the subframe decode buffer
+    DECLARE_ALIGNED_16(float, out[WMAPRO_BLOCK_MAX_SIZE + WMAPRO_BLOCK_MAX_SIZE / 2]); ///< output buffer
+} WMAProChannelCtx;
+
+/**
+ * @brief channel group for channel transformations
+ */
+typedef struct {
+    uint8_t num_channels;                                     ///< number of channels in the group
+    int8_t  transform;                                        ///< transform on / off
+    int8_t  transform_band[MAX_BANDS];                        ///< controls if the transform is enabled for a certain band
+    float   decorrelation_matrix[WMAPRO_MAX_CHANNELS*WMAPRO_MAX_CHANNELS];
+    float*  channel_data[WMAPRO_MAX_CHANNELS];                ///< transformation coefficients
+} WMAProChannelGrp;
+
+/**
+ * @brief main decoder context
+ */
+typedef struct WMAProDecodeCtx {
+    /* generic decoder variables */
+    AVCodecContext*  avctx;                         ///< codec context for av_log
+    DSPContext       dsp;                           ///< accelerated DSP functions
+    uint8_t          frame_data[MAX_FRAMESIZE +
+                      FF_INPUT_BUFFER_PADDING_SIZE];///< compressed frame data
+    PutBitContext    pb;                            ///< context for filling the frame_data buffer
+    MDCTContext      mdct_ctx[WMAPRO_BLOCK_SIZES];  ///< MDCT context per block size
+    DECLARE_ALIGNED_16(float, tmp[WMAPRO_BLOCK_MAX_SIZE]); ///< IMDCT output buffer
+    float*           windows[WMAPRO_BLOCK_SIZES];   ///< windows for the different block sizes
+
+    /* frame size dependent frame information (set during initialization) */
+    uint32_t         decode_flags;                  ///< used compression features
+    uint8_t          len_prefix;                    ///< frame is prefixed with its length
+    uint8_t          dynamic_range_compression;     ///< frame contains DRC data
+    uint8_t          bits_per_sample;               ///< integer audio sample size for the unscaled IMDCT output (used to scale to [-1.0, 1.0])
+    uint16_t         samples_per_frame;             ///< number of samples to output
+    uint16_t         log2_frame_size;
+    int8_t           num_channels;                  ///< number of channels in the stream (same as AVCodecContext.num_channels)
+    int8_t           lfe_channel;                   ///< lfe channel index
+    uint8_t          max_num_subframes;
+    uint8_t          subframe_len_bits;             ///< number of bits used for the subframe length
+    uint8_t          max_subframe_len_bit;          ///< flag indicating that the subframe is of maximum size when the first subframe length bit is 1
+    uint16_t         min_samples_per_subframe;
+    int8_t           num_sfb[WMAPRO_BLOCK_SIZES];   ///< scale factor bands per block size
+    int16_t          sfb_offsets[WMAPRO_BLOCK_SIZES][MAX_BANDS];                    ///< scale factor band offsets (multiples of 4)
+    int8_t           sf_offsets[WMAPRO_BLOCK_SIZES][WMAPRO_BLOCK_SIZES][MAX_BANDS]; ///< scale factor resample matrix
+    int16_t          subwoofer_cutoffs[WMAPRO_BLOCK_SIZES]; ///< subwoofer cutoff values
+
+    /* packet decode state */
+    GetBitContext    pgb;                           ///< bitstream reader context for the packet
+    uint8_t          packet_offset;                 ///< frame offset in the packet
+    uint8_t          packet_sequence_number;        ///< current packet number
+    int              num_saved_bits;                ///< saved number of bits
+    int              frame_offset;                  ///< frame offset in the bit reservoir
+    int              subframe_offset;               ///< subframe offset in the bit reservoir
+    uint8_t          packet_loss;                   ///< set in case of bitstream error
+    uint8_t          packet_done;                   ///< set when a packet is fully decoded
+
+    /* frame decode state */
+    uint32_t         frame_num;                     ///< current frame number (not used for decoding)
+    GetBitContext    gb;                            ///< bitstream reader context
+    int              buf_bit_size;                  ///< buffer size in bits
+    float*           samples;                       ///< current samplebuffer pointer
+    float*           samples_end;                   ///< maximum samplebuffer pointer
+    uint8_t          drc_gain;                      ///< gain for the DRC tool
+    int8_t           skip_frame;                    ///< skip output step
+    int8_t           parsed_all_subframes;          ///< all subframes decoded?
+
+    /* subframe/block decode state */
+    int16_t          subframe_len;                  ///< current subframe length
+    int8_t           channels_for_cur_subframe;     ///< number of channels that contain the subframe
+    int8_t           channel_indexes_for_cur_subframe[WMAPRO_MAX_CHANNELS];
+    int8_t           num_bands;                     ///< number of scale factor bands
+    int16_t*         cur_sfb_offsets;               ///< sfb offsets for the current block
+    uint8_t          table_idx;                     ///< index for the num_sfb, sfb_offsets, sf_offsets and subwoofer_cutoffs tables
+    int8_t           esc_len;                       ///< length of escaped coefficients
+
+    uint8_t          num_chgroups;                  ///< number of channel groups
+    WMAProChannelGrp chgroup[WMAPRO_MAX_CHANNELS];  ///< channel group information
+
+    WMAProChannelCtx channel[WMAPRO_MAX_CHANNELS];  ///< per channel data
+} WMAProDecodeCtx;
+
+
+/**
+ *@brief helper function to print the most important members of the context
+ *@param s context
+ */
+static void av_cold dump_context(WMAProDecodeCtx *s)
+{
+#define PRINT(a, b)     av_log(s->avctx, AV_LOG_DEBUG, " %s = %d\n", a, b);
+#define PRINT_HEX(a, b) av_log(s->avctx, AV_LOG_DEBUG, " %s = %x\n", a, b);
+
+    PRINT("ed sample bit depth", s->bits_per_sample);
+    PRINT_HEX("ed decode flags", s->decode_flags);
+    PRINT("samples per frame",   s->samples_per_frame);
+    PRINT("log2 frame size",     s->log2_frame_size);
+    PRINT("max num subframes",   s->max_num_subframes);
+    PRINT("len prefix",          s->len_prefix);
+    PRINT("num channels",        s->num_channels);
+}
+
+/**
+ *@brief Uninitialize the decoder and free all resources.
+ *@param avctx codec context
+ *@return 0 on success, < 0 otherwise
+ */
+static av_cold int decode_end(AVCodecContext *avctx)
+{
+    WMAProDecodeCtx *s = avctx->priv_data;
+    int i;
+
+    for (i = 0; i < WMAPRO_BLOCK_SIZES; i++)
+        ff_mdct_end(&s->mdct_ctx[i]);
+
+    return 0;
+}
+
+/**
+ *@brief Initialize the decoder.
+ *@param avctx codec context
+ *@return 0 on success, -1 otherwise
+ */
+static av_cold int decode_init(AVCodecContext *avctx)
+{
+    WMAProDecodeCtx *s = avctx->priv_data;
+    uint8_t *edata_ptr = avctx->extradata;
+    unsigned int channel_mask;
+    int i;
+    int log2_max_num_subframes;
+    int num_possible_block_sizes;
+
+    s->avctx = avctx;
+    dsputil_init(&s->dsp, avctx);
+    init_put_bits(&s->pb, s->frame_data, MAX_FRAMESIZE);
+
+    avctx->sample_fmt = SAMPLE_FMT_FLT;
+
+    if (avctx->extradata_size >= 18) {
+        s->decode_flags    = AV_RL16(edata_ptr+14);
+        channel_mask       = AV_RL32(edata_ptr+2);
+        s->bits_per_sample = AV_RL16(edata_ptr);
+        /** dump the extradata */
+        for (i = 0; i < avctx->extradata_size; i++)
+            dprintf(avctx, "[%x] ", avctx->extradata[i]);
+        dprintf(avctx, "\n");
+
+    } else {
+        ff_log_ask_for_sample(avctx, "Unknown extradata size\n");
+        return AVERROR_INVALIDDATA;
+    }
+
+    /** generic init */
+    s->log2_frame_size = av_log2(avctx->block_align) + 4;
+
+    /** frame info */
+    s->skip_frame  = 1; /** skip first frame */
+    s->packet_loss = 1;
+    s->len_prefix  = (s->decode_flags & 0x40);
+
+    if (!s->len_prefix) {
+        ff_log_ask_for_sample(avctx, "no length prefix\n");
+        return AVERROR_INVALIDDATA;
+    }
+
+    /** get frame len */
+    s->samples_per_frame = 1 << ff_wma_get_frame_len_bits(avctx->sample_rate,
+                                                          3, s->decode_flags);
+
+    /** init previous block len */
+    for (i = 0; i < avctx->channels; i++)
+        s->channel[i].prev_block_len = s->samples_per_frame;
+
+    /** subframe info */
+    log2_max_num_subframes       = ((s->decode_flags & 0x38) >> 3);
+    s->max_num_subframes         = 1 << log2_max_num_subframes;
+    if (s->max_num_subframes == 16)
+        s->max_subframe_len_bit = 1;
+    s->subframe_len_bits = av_log2(log2_max_num_subframes) + 1;
+
+    num_possible_block_sizes     = log2_max_num_subframes + 1;
+    s->min_samples_per_subframe  = s->samples_per_frame / s->max_num_subframes;
+    s->dynamic_range_compression = (s->decode_flags & 0x80);
+
+    if (s->max_num_subframes > MAX_SUBFRAMES) {
+        av_log(avctx, AV_LOG_ERROR, "invalid number of subframes %i\n",
+               s->max_num_subframes);
+        return AVERROR_INVALIDDATA;
+    }
+
+    s->num_channels = avctx->channels;
+
+    /** extract lfe channel position */
+    s->lfe_channel = -1;
+
+    if (channel_mask & 8) {
+        unsigned int mask;
+        for (mask = 1; mask < 16; mask <<= 1) {
+            if (channel_mask & mask)
+                ++s->lfe_channel;
+        }
+    }
+
+    if (s->num_channels < 0 || s->num_channels > WMAPRO_MAX_CHANNELS) {
+        ff_log_ask_for_sample(avctx, "invalid number of channels\n");
+        return AVERROR_NOTSUPP;
+    }
+
+    INIT_VLC_STATIC(&sf_vlc, SCALEVLCBITS, HUFF_SCALE_SIZE,
+                    scale_huffbits, 1, 1,
+                    scale_huffcodes, 2, 2, 616);
+
+    INIT_VLC_STATIC(&sf_rl_vlc, VLCBITS, HUFF_SCALE_RL_SIZE,
+                    scale_rl_huffbits, 1, 1,
+                    scale_rl_huffcodes, 4, 4, 1406);
+
+    INIT_VLC_STATIC(&coef_vlc[0], VLCBITS, HUFF_COEF0_SIZE,
+                    coef0_huffbits, 1, 1,
+                    coef0_huffcodes, 4, 4, 2108);
+
+    INIT_VLC_STATIC(&coef_vlc[1], VLCBITS, HUFF_COEF1_SIZE,
+                    coef1_huffbits, 1, 1,
+                    coef1_huffcodes, 4, 4, 3912);
+
+    INIT_VLC_STATIC(&vec4_vlc, VLCBITS, HUFF_VEC4_SIZE,
+                    vec4_huffbits, 1, 1,
+                    vec4_huffcodes, 2, 2, 604);
+
+    INIT_VLC_STATIC(&vec2_vlc, VLCBITS, HUFF_VEC2_SIZE,
+                    vec2_huffbits, 1, 1,
+                    vec2_huffcodes, 2, 2, 562);
+
+    INIT_VLC_STATIC(&vec1_vlc, VLCBITS, HUFF_VEC1_SIZE,
+                    vec1_huffbits, 1, 1,
+                    vec1_huffcodes, 2, 2, 562);
+
+    /** calculate number of scale factor bands and their offsets
+        for every possible block size */
+    for (i = 0; i < num_possible_block_sizes; i++) {
+        int subframe_len = s->samples_per_frame >> i;
+        int x;
+        int band = 1;
+
+        s->sfb_offsets[i][0] = 0;
+
+        for (x = 0; x < MAX_BANDS-1 && s->sfb_offsets[i][band - 1] < subframe_len; x++) {
+            int offset = (subframe_len * 2 * critical_freq[x])
+                          / s->avctx->sample_rate + 2;
+            offset &= ~3;
+            if (offset > s->sfb_offsets[i][band - 1])
+                s->sfb_offsets[i][band++] = offset;
+        }
+        s->sfb_offsets[i][band - 1] = subframe_len;
+        s->num_sfb[i]               = band - 1;
+    }
+
+
+    /** Scale factors can be shared between blocks of different size
+        as every block has a different scale factor band layout.
+        The matrix sf_offsets is needed to find the correct scale factor.
+     */
+
+    for (i = 0; i < num_possible_block_sizes; i++) {
+        int b;
+        for (b = 0; b < s->num_sfb[i]; b++) {
+            int x;
+            int offset = ((s->sfb_offsets[i][b]
+                           + s->sfb_offsets[i][b + 1] - 1) << i) >> 1;
+            for (x = 0; x < num_possible_block_sizes; x++) {
+                int v = 0;
+                while (s->sfb_offsets[x][v + 1] << x < offset)
+                    ++v;
+                s->sf_offsets[i][x][b] = v;
+            }
+        }
+    }
+
+    /** init MDCT, FIXME: only init needed sizes */
+    for (i = 0; i < WMAPRO_BLOCK_SIZES; i++)
+        ff_mdct_init_backport(&s->mdct_ctx[i], BLOCK_MIN_BITS+1+i, 1,
+                     1.0 / (1 << (BLOCK_MIN_BITS + i - 1))
+                     / (1 << (s->bits_per_sample - 1)));
+
+    /** init MDCT windows: simple sinus window */
+    for (i = 0; i < WMAPRO_BLOCK_SIZES; i++) {
+        const int n       = 1 << (WMAPRO_BLOCK_MAX_BITS - i);
+        const int win_idx = WMAPRO_BLOCK_MAX_BITS - i - 7;
+        ff_sine_window_init(ff_sine_windows[win_idx], n);
+        s->windows[WMAPRO_BLOCK_SIZES - i - 1] = ff_sine_windows[win_idx];
+    }
+
+    /** calculate subwoofer cutoff values */
+    for (i = 0; i < num_possible_block_sizes; i++) {
+        int block_size = s->samples_per_frame >> i;
+        int cutoff = (440*block_size + 3 * (s->avctx->sample_rate >> 1) - 1)
+                     / s->avctx->sample_rate;
+        s->subwoofer_cutoffs[i] = av_clip(cutoff, 4, block_size);
+    }
+
+    /** calculate sine values for the decorrelation matrix */
+    for (i = 0; i < 33; i++)
+        sin64[i] = sin(i*M_PI / 64.0);
+
+    if (avctx->debug & FF_DEBUG_BITSTREAM)
+        dump_context(s);
+
+    avctx->channel_layout = channel_mask;
+    return 0;
+}
+
+/**
+ *@brief Decode the subframe length.
+ *@param s context
+ *@param offset sample offset in the frame
+ *@return decoded subframe length on success, < 0 in case of an error
+ */
+static int decode_subframe_length(WMAProDecodeCtx *s, int offset)
+{
+    int frame_len_shift = 0;
+    int subframe_len;
+
+    /** no need to read from the bitstream when only one length is possible */
+    if (offset == s->samples_per_frame - s->min_samples_per_subframe)
+        return s->min_samples_per_subframe;
+
+    /** 1 bit indicates if the subframe is of maximum length */
+    if (s->max_subframe_len_bit) {
+        if (get_bits1(&s->gb))
+            frame_len_shift = 1 + get_bits(&s->gb, s->subframe_len_bits-1);
+    } else
+        frame_len_shift = get_bits(&s->gb, s->subframe_len_bits);
+
+    subframe_len = s->samples_per_frame >> frame_len_shift;
+
+    /** sanity check the length */
+    if (subframe_len < s->min_samples_per_subframe ||
+        subframe_len > s->samples_per_frame) {
+        av_log(s->avctx, AV_LOG_ERROR, "broken frame: subframe_len %i\n",
+               subframe_len);
+        return AVERROR_INVALIDDATA;
+    }
+    return subframe_len;
+}
+
+/**
+ *@brief Decode how the data in the frame is split into subframes.
+ *       Every WMA frame contains the encoded data for a fixed number of
+ *       samples per channel. The data for every channel might be split
+ *       into several subframes. This function will reconstruct the list of
+ *       subframes for every channel.
+ *
+ *       If the subframes are not evenly split, the algorithm estimates the
+ *       channels with the lowest number of total samples.
+ *       Afterwards, for each of these channels a bit is read from the
+ *       bitstream that indicates if the channel contains a subframe with the
+ *       next subframe size that is going to be read from the bitstream or not.
+ *       If a channel contains such a subframe, the subframe size gets added to
+ *       the channel's subframe list.
+ *       The algorithm repeats these steps until the frame is properly divided
+ *       between the individual channels.
+ *
+ *@param s context
+ *@return 0 on success, < 0 in case of an error
+ */
+static int decode_tilehdr(WMAProDecodeCtx *s)
+{
+    uint16_t num_samples[WMAPRO_MAX_CHANNELS];        /** sum of samples for all currently known subframes of a channel */
+    uint8_t  contains_subframe[WMAPRO_MAX_CHANNELS];  /** flag indicating if a channel contains the current subframe */
+    int channels_for_cur_subframe = s->num_channels;  /** number of channels that contain the current subframe */
+    int fixed_channel_layout = 0;                     /** flag indicating that all channels use the same subframe offsets and sizes */
+    int min_channel_len = 0;                          /** smallest sum of samples (channels with this length will be processed first) */
+    int c;
+
+    /* Should never consume more than 3073 bits (256 iterations for the
+     * while loop when always the minimum amount of 128 samples is substracted
+     * from missing samples in the 8 channel case).
+     * 1 + BLOCK_MAX_SIZE * MAX_CHANNELS / BLOCK_MIN_SIZE * (MAX_CHANNELS  + 4)
+     */
+
+    /** reset tiling information */
+    for (c = 0; c < s->num_channels; c++)
+        s->channel[c].num_subframes = 0;
+
+    memset(num_samples, 0, sizeof(num_samples));
+
+    if (s->max_num_subframes == 1 || get_bits1(&s->gb))
+        fixed_channel_layout = 1;
+
+    /** loop until the frame data is split between the subframes */
+    do {
+        int subframe_len;
+
+        /** check which channels contain the subframe */
+        for (c = 0; c < s->num_channels; c++) {
+            if (num_samples[c] == min_channel_len) {
+                if (fixed_channel_layout || channels_for_cur_subframe == 1 ||
+                   (min_channel_len == s->samples_per_frame - s->min_samples_per_subframe))
+                    contains_subframe[c] = 1;
+                else
+                    contains_subframe[c] = get_bits1(&s->gb);
+            } else
+                contains_subframe[c] = 0;
+        }
+
+        /** get subframe length, subframe_len == 0 is not allowed */
+        if ((subframe_len = decode_subframe_length(s, min_channel_len)) <= 0)
+            return AVERROR_INVALIDDATA;
+
+        /** add subframes to the individual channels and find new min_channel_len */
+        min_channel_len += subframe_len;
+        for (c = 0; c < s->num_channels; c++) {
+            WMAProChannelCtx* chan = &s->channel[c];
+
+            if (contains_subframe[c]) {
+                if (chan->num_subframes >= MAX_SUBFRAMES) {
+                    av_log(s->avctx, AV_LOG_ERROR,
+                           "broken frame: num subframes > 31\n");
+                    return AVERROR_INVALIDDATA;
+                }
+                chan->subframe_len[chan->num_subframes] = subframe_len;
+                num_samples[c] += subframe_len;
+                ++chan->num_subframes;
+                if (num_samples[c] > s->samples_per_frame) {
+                    av_log(s->avctx, AV_LOG_ERROR, "broken frame: "
+                           "channel len > samples_per_frame\n");
+                    return AVERROR_INVALIDDATA;
+                }
+            } else if (num_samples[c] <= min_channel_len) {
+                if (num_samples[c] < min_channel_len) {
+                    channels_for_cur_subframe = 0;
+                    min_channel_len = num_samples[c];
+                }
+                ++channels_for_cur_subframe;
+            }
+        }
+    } while (min_channel_len < s->samples_per_frame);
+
+    for (c = 0; c < s->num_channels; c++) {
+        int i;
+        int offset = 0;
+        for (i = 0; i < s->channel[c].num_subframes; i++) {
+            dprintf(s->avctx, "frame[%i] channel[%i] subframe[%i]"
+                    " len %i\n", s->frame_num, c, i,
+                    s->channel[c].subframe_len[i]);
+            s->channel[c].subframe_offset[i] = offset;
+            offset += s->channel[c].subframe_len[i];
+        }
+    }
+
+    return 0;
+}
+
+/**
+ *@brief Calculate a decorrelation matrix from the bitstream parameters.
+ *@param s codec context
+ *@param chgroup channel group for which the matrix needs to be calculated
+ */
+static void decode_decorrelation_matrix(WMAProDecodeCtx *s,
+                                        WMAProChannelGrp *chgroup)
+{
+    int i;
+    int offset = 0;
+    int8_t rotation_offset[WMAPRO_MAX_CHANNELS * WMAPRO_MAX_CHANNELS];
+    memset(chgroup->decorrelation_matrix, 0, s->num_channels *
+           s->num_channels * sizeof(*chgroup->decorrelation_matrix));
+
+    for (i = 0; i < chgroup->num_channels * (chgroup->num_channels - 1) >> 1; i++)
+        rotation_offset[i] = get_bits(&s->gb, 6);
+
+    for (i = 0; i < chgroup->num_channels; i++)
+        chgroup->decorrelation_matrix[chgroup->num_channels * i + i] =
+            get_bits1(&s->gb) ? 1.0 : -1.0;
+
+    for (i = 1; i < chgroup->num_channels; i++) {
+        int x;
+        for (x = 0; x < i; x++) {
+            int y;
+            for (y = 0; y < i + 1; y++) {
+                float v1 = chgroup->decorrelation_matrix[x * chgroup->num_channels + y];
+                float v2 = chgroup->decorrelation_matrix[i * chgroup->num_channels + y];
+                int n = rotation_offset[offset + x];
+                float sinv;
+                float cosv;
+
+                if (n < 32) {
+                    sinv = sin64[n];
+                    cosv = sin64[32 - n];
+                } else {
+                    sinv =  sin64[64 -  n];
+                    cosv = -sin64[n  - 32];
+                }
+
+                chgroup->decorrelation_matrix[y + x * chgroup->num_channels] =
+                                               (v1 * sinv) - (v2 * cosv);
+                chgroup->decorrelation_matrix[y + i * chgroup->num_channels] =
+                                               (v1 * cosv) + (v2 * sinv);
+            }
+        }
+        offset += i;
+    }
+}
+
+/**
+ *@brief Decode channel transformation parameters
+ *@param s codec context
+ *@return 0 in case of success, < 0 in case of bitstream errors
+ */
+static int decode_channel_transform(WMAProDecodeCtx* s)
+{
+    int i;
+    /* should never consume more than 1921 bits for the 8 channel case
+     * 1 + MAX_CHANNELS * (MAX_CHANNELS + 2 + 3 * MAX_CHANNELS * MAX_CHANNELS
+     * + MAX_CHANNELS + MAX_BANDS + 1)
+     */
+
+    /** in the one channel case channel transforms are pointless */
+    s->num_chgroups = 0;
+    if (s->num_channels > 1) {
+        int remaining_channels = s->channels_for_cur_subframe;
+
+        if (get_bits1(&s->gb)) {
+            ff_log_ask_for_sample(s->avctx,
+                                  "unsupported channel transform bit\n");
+            return AVERROR_INVALIDDATA;
+        }
+
+        for (s->num_chgroups = 0; remaining_channels &&
+             s->num_chgroups < s->channels_for_cur_subframe; s->num_chgroups++) {
+            WMAProChannelGrp* chgroup = &s->chgroup[s->num_chgroups];
+            float** channel_data = chgroup->channel_data;
+            chgroup->num_channels = 0;
+            chgroup->transform = 0;
+
+            /** decode channel mask */
+            if (remaining_channels > 2) {
+                for (i = 0; i < s->channels_for_cur_subframe; i++) {
+                    int channel_idx = s->channel_indexes_for_cur_subframe[i];
+                    if (!s->channel[channel_idx].grouped
+                        && get_bits1(&s->gb)) {
+                        ++chgroup->num_channels;
+                        s->channel[channel_idx].grouped = 1;
+                        *channel_data++ = s->channel[channel_idx].coeffs;
+                    }
+                }
+            } else {
+                chgroup->num_channels = remaining_channels;
+                for (i = 0; i < s->channels_for_cur_subframe; i++) {
+                    int channel_idx = s->channel_indexes_for_cur_subframe[i];
+                    if (!s->channel[channel_idx].grouped)
+                        *channel_data++ = s->channel[channel_idx].coeffs;
+                    s->channel[channel_idx].grouped = 1;
+                }
+            }
+
+            /** decode transform type */
+            if (chgroup->num_channels == 2) {
+                if (get_bits1(&s->gb)) {
+                    if (get_bits1(&s->gb)) {
+                        ff_log_ask_for_sample(s->avctx,
+                                              "unsupported channel transform type\n");
+                    }
+                } else {
+                    chgroup->transform = 1;
+                    if (s->num_channels == 2) {
+                        chgroup->decorrelation_matrix[0] =  1.0;
+                        chgroup->decorrelation_matrix[1] = -1.0;
+                        chgroup->decorrelation_matrix[2] =  1.0;
+                        chgroup->decorrelation_matrix[3] =  1.0;
+                    } else {
+                        /** cos(pi/4) */
+                        chgroup->decorrelation_matrix[0] =  0.70703125;
+                        chgroup->decorrelation_matrix[1] = -0.70703125;
+                        chgroup->decorrelation_matrix[2] =  0.70703125;
+                        chgroup->decorrelation_matrix[3] =  0.70703125;
+                    }
+                }
+            } else if (chgroup->num_channels > 2) {
+                if (get_bits1(&s->gb)) {
+                    chgroup->transform = 1;
+                    if (get_bits1(&s->gb)) {
+                        decode_decorrelation_matrix(s, chgroup);
+                    } else {
+                        /** FIXME: more than 6 coupled channels not supported */
+                        if (chgroup->num_channels > 6) {
+                            ff_log_ask_for_sample(s->avctx,
+                                                  "coupled channels > 6\n");
+                        } else {
+                            memcpy(chgroup->decorrelation_matrix,
+                                   default_decorrelation[chgroup->num_channels],
+                                   chgroup->num_channels * chgroup->num_channels *
+                                   sizeof(*chgroup->decorrelation_matrix));
+                        }
+                    }
+                }
+            }
+
+            /** decode transform on / off */
+            if (chgroup->transform) {
+                if (!get_bits1(&s->gb)) {
+                    int i;
+                    /** transform can be enabled for individual bands */
+                    for (i = 0; i < s->num_bands; i++) {
+                        chgroup->transform_band[i] = get_bits1(&s->gb);
+                    }
+                } else {
+                    memset(chgroup->transform_band, 1, s->num_bands);
+                }
+            }
+            remaining_channels -= chgroup->num_channels;
+        }
+    }
+    return 0;
+}
+
+/**
+ *@brief Extract the coefficients from the bitstream.
+ *@param s codec context
+ *@param c current channel number
+ *@return 0 on success, < 0 in case of bitstream errors
+ */
+static int decode_coeffs(WMAProDecodeCtx *s, int c)
+{
+    /* Integers 0..15 as single-precision floats.  The table saves a
+       costly int to float conversion, and storing the values as
+       integers allows fast sign-flipping. */
+    static const int fval_tab[16] = {
+        0x00000000, 0x3f800000, 0x40000000, 0x40400000,
+        0x40800000, 0x40a00000, 0x40c00000, 0x40e00000,
+        0x41000000, 0x41100000, 0x41200000, 0x41300000,
+        0x41400000, 0x41500000, 0x41600000, 0x41700000,
+    };
+    int vlctable;
+    VLC* vlc;
+    WMAProChannelCtx* ci = &s->channel[c];
+    int rl_mode = 0;
+    int cur_coeff = 0;
+    int num_zeros = 0;
+    const uint16_t* run;
+    const uint16_t* level;
+
+    dprintf(s->avctx, "decode coefficients for channel %i\n", c);
+
+    vlctable = get_bits1(&s->gb);
+    vlc = &coef_vlc[vlctable];
+
+    if (vlctable) {
+        run = coef1_run;
+        level = coef1_level;
+    } else {
+        run = coef0_run;
+        level = coef0_level;
+    }
+
+    /** decode vector coefficients (consumes up to 167 bits per iteration for
+      4 vector coded large values) */
+    while (!rl_mode && cur_coeff + 3 < s->subframe_len) {
+        int vals[4];
+        int i;
+        unsigned int idx;
+
+        idx = get_vlc2(&s->gb, vec4_vlc.table, VLCBITS, VEC4MAXDEPTH);
+
+        if (idx == HUFF_VEC4_SIZE - 1) {
+            for (i = 0; i < 4; i += 2) {
+                idx = get_vlc2(&s->gb, vec2_vlc.table, VLCBITS, VEC2MAXDEPTH);
+                if (idx == HUFF_VEC2_SIZE - 1) {
+                    int v0, v1;
+                    v0 = get_vlc2(&s->gb, vec1_vlc.table, VLCBITS, VEC1MAXDEPTH);
+                    if (v0 == HUFF_VEC1_SIZE - 1)
+                        v0 += ff_wma_get_large_val(&s->gb);
+                    v1 = get_vlc2(&s->gb, vec1_vlc.table, VLCBITS, VEC1MAXDEPTH);
+                    if (v1 == HUFF_VEC1_SIZE - 1)
+                        v1 += ff_wma_get_large_val(&s->gb);
+                    ((float*)vals)[i  ] = v0;
+                    ((float*)vals)[i+1] = v1;
+                } else {
+                    vals[i]   = fval_tab[symbol_to_vec2[idx] >> 4 ];
+                    vals[i+1] = fval_tab[symbol_to_vec2[idx] & 0xF];
+                }
+            }
+        } else {
+            vals[0] = fval_tab[ symbol_to_vec4[idx] >> 12      ];
+            vals[1] = fval_tab[(symbol_to_vec4[idx] >> 8) & 0xF];
+            vals[2] = fval_tab[(symbol_to_vec4[idx] >> 4) & 0xF];
+            vals[3] = fval_tab[ symbol_to_vec4[idx]       & 0xF];
+        }
+
+        /** decode sign */
+        for (i = 0; i < 4; i++) {
+            if (vals[i]) {
+                int sign = get_bits1(&s->gb) - 1;
+                *(uint32_t*)&ci->coeffs[cur_coeff] = vals[i] ^ sign<<31;
+                num_zeros = 0;
+            } else {
+                ci->coeffs[cur_coeff] = 0;
+                /** switch to run level mode when subframe_len / 128 zeros
+                    were found in a row */
+                rl_mode |= (++num_zeros > s->subframe_len >> 8);
+            }
+            ++cur_coeff;
+        }
+    }
+
+    /** decode run level coded coefficients */
+    if (rl_mode) {
+        memset(&ci->coeffs[cur_coeff], 0,
+               sizeof(*ci->coeffs) * (s->subframe_len - cur_coeff));
+        if (ff_wma_run_level_decode(s->avctx, &s->gb, vlc,
+                                    level, run, 1, ci->coeffs,
+                                    cur_coeff, s->subframe_len,
+                                    s->subframe_len, s->esc_len, 0))
+            return AVERROR_INVALIDDATA;
+    }
+
+    return 0;
+}
+
+/**
+ *@brief Extract scale factors from the bitstream.
+ *@param s codec context
+ *@return 0 on success, < 0 in case of bitstream errors
+ */
+static int decode_scale_factors(WMAProDecodeCtx* s)
+{
+    int i;
+
+    /** should never consume more than 5344 bits
+     *  MAX_CHANNELS * (1 +  MAX_BANDS * 23)
+     */
+
+    for (i = 0; i < s->channels_for_cur_subframe; i++) {
+        int c = s->channel_indexes_for_cur_subframe[i];
+        int* sf;
+        int* sf_end;
+        s->channel[c].scale_factors = s->channel[c].saved_scale_factors[!s->channel[c].scale_factor_idx];
+        sf_end = s->channel[c].scale_factors + s->num_bands;
+
+        /** resample scale factors for the new block size
+         *  as the scale factors might need to be resampled several times
+         *  before some  new values are transmitted, a backup of the last
+         *  transmitted scale factors is kept in saved_scale_factors
+         */
+        if (s->channel[c].reuse_sf) {
+            const int8_t* sf_offsets = s->sf_offsets[s->table_idx][s->channel[c].table_idx];
+            int b;
+            for (b = 0; b < s->num_bands; b++)
+                s->channel[c].scale_factors[b] =
+                    s->channel[c].saved_scale_factors[s->channel[c].scale_factor_idx][*sf_offsets++];
+        }
+
+        if (!s->channel[c].cur_subframe || get_bits1(&s->gb)) {
+
+            if (!s->channel[c].reuse_sf) {
+                int val;
+                /** decode DPCM coded scale factors */
+                s->channel[c].scale_factor_step = get_bits(&s->gb, 2) + 1;
+                val = 45 / s->channel[c].scale_factor_step;
+                for (sf = s->channel[c].scale_factors; sf < sf_end; sf++) {
+                    val += get_vlc2(&s->gb, sf_vlc.table, SCALEVLCBITS, SCALEMAXDEPTH) - 60;
+                    *sf = val;
+                }
+            } else {
+                int i;
+                /** run level decode differences to the resampled factors */
+                for (i = 0; i < s->num_bands; i++) {
+                    int idx;
+                    int skip;
+                    int val;
+                    int sign;
+
+                    idx = get_vlc2(&s->gb, sf_rl_vlc.table, VLCBITS, SCALERLMAXDEPTH);
+
+                    if (!idx) {
+                        uint32_t code = get_bits(&s->gb, 14);
+                        val  =  code >> 6;
+                        sign = (code & 1) - 1;
+                        skip = (code & 0x3f) >> 1;
+                    } else if (idx == 1) {
+                        break;
+                    } else {
+                        skip = scale_rl_run[idx];
+                        val  = scale_rl_level[idx];
+                        sign = get_bits1(&s->gb)-1;
+                    }
+
+                    i += skip;
+                    if (i >= s->num_bands) {
+                        av_log(s->avctx, AV_LOG_ERROR,
+                               "invalid scale factor coding\n");
+                        return AVERROR_INVALIDDATA;
+                    }
+                    s->channel[c].scale_factors[i] += (val ^ sign) - sign;
+                }
+            }
+            /** swap buffers */
+            s->channel[c].scale_factor_idx = !s->channel[c].scale_factor_idx;
+            s->channel[c].table_idx = s->table_idx;
+            s->channel[c].reuse_sf  = 1;
+        }
+
+        /** calculate new scale factor maximum */
+        s->channel[c].max_scale_factor = s->channel[c].scale_factors[0];
+        for (sf = s->channel[c].scale_factors + 1; sf < sf_end; sf++) {
+            s->channel[c].max_scale_factor =
+                FFMAX(s->channel[c].max_scale_factor, *sf);
+        }
+
+    }
+    return 0;
+}
+
+/**
+ *@brief Reconstruct the individual channel data.
+ *@param s codec context
+ */
+static void inverse_channel_transform(WMAProDecodeCtx *s)
+{
+    int i;
+
+    for (i = 0; i < s->num_chgroups; i++) {
+        if (s->chgroup[i].transform) {
+            float data[WMAPRO_MAX_CHANNELS];
+            const int num_channels = s->chgroup[i].num_channels;
+            float** ch_data = s->chgroup[i].channel_data;
+            float** ch_end = ch_data + num_channels;
+            const int8_t* tb = s->chgroup[i].transform_band;
+            int16_t* sfb;
+
+            /** multichannel decorrelation */
+            for (sfb = s->cur_sfb_offsets;
+                 sfb < s->cur_sfb_offsets + s->num_bands; sfb++) {
+                int y;
+                if (*tb++ == 1) {
+                    /** multiply values with the decorrelation_matrix */
+                    for (y = sfb[0]; y < FFMIN(sfb[1], s->subframe_len); y++) {
+                        const float* mat = s->chgroup[i].decorrelation_matrix;
+                        const float* data_end = data + num_channels;
+                        float* data_ptr = data;
+                        float** ch;
+
+                        for (ch = ch_data; ch < ch_end; ch++)
+                            *data_ptr++ = (*ch)[y];
+
+                        for (ch = ch_data; ch < ch_end; ch++) {
+                            float sum = 0;
+                            data_ptr = data;
+                            while (data_ptr < data_end)
+                                sum += *data_ptr++ * *mat++;
+
+                            (*ch)[y] = sum;
+                        }
+                    }
+                } else if (s->num_channels == 2) {
+                    int len = FFMIN(sfb[1], s->subframe_len) - sfb[0];
+                    s->dsp.vector_fmul_scalar(ch_data[0] + sfb[0],
+                                              ch_data[0] + sfb[0],
+                                              181.0 / 128, len);
+                    s->dsp.vector_fmul_scalar(ch_data[1] + sfb[0],
+                                              ch_data[1] + sfb[0],
+                                              181.0 / 128, len);
+                }
+            }
+        }
+    }
+}
+
+/**
+ *@brief Apply sine window and reconstruct the output buffer.
+ *@param s codec context
+ */
+static void wmapro_window(WMAProDecodeCtx *s)
+{
+    int i;
+    for (i = 0; i < s->channels_for_cur_subframe; i++) {
+        int c = s->channel_indexes_for_cur_subframe[i];
+        float* window;
+        int winlen = s->channel[c].prev_block_len;
+        float* start = s->channel[c].coeffs - (winlen >> 1);
+
+        if (s->subframe_len < winlen) {
+            start += (winlen - s->subframe_len) >> 1;
+            winlen = s->subframe_len;
+        }
+
+        window = s->windows[av_log2(winlen) - BLOCK_MIN_BITS];
+
+        winlen >>= 1;
+
+        s->dsp.vector_fmul_window(start, start, start + winlen,
+                                  window, 0, winlen);
+
+        s->channel[c].prev_block_len = s->subframe_len;
+    }
+}
+
+/**
+ *@brief Decode a single subframe (block).
+ *@param s codec context
+ *@return 0 on success, < 0 when decoding failed
+ */
+static int decode_subframe(WMAProDecodeCtx *s)
+{
+    int offset = s->samples_per_frame;
+    int subframe_len = s->samples_per_frame;
+    int i;
+    int total_samples   = s->samples_per_frame * s->num_channels;
+    int transmit_coeffs = 0;
+    int cur_subwoofer_cutoff;
+
+    s->subframe_offset = get_bits_count(&s->gb);
+
+    /** reset channel context and find the next block offset and size
+        == the next block of the channel with the smallest number of
+        decoded samples
+    */
+    for (i = 0; i < s->num_channels; i++) {
+        s->channel[i].grouped = 0;
+        if (offset > s->channel[i].decoded_samples) {
+            offset = s->channel[i].decoded_samples;
+            subframe_len =
+                s->channel[i].subframe_len[s->channel[i].cur_subframe];
+        }
+    }
+
+    dprintf(s->avctx,
+            "processing subframe with offset %i len %i\n", offset, subframe_len);
+
+    /** get a list of all channels that contain the estimated block */
+    s->channels_for_cur_subframe = 0;
+    for (i = 0; i < s->num_channels; i++) {
+        const int cur_subframe = s->channel[i].cur_subframe;
+        /** substract already processed samples */
+        total_samples -= s->channel[i].decoded_samples;
+
+        /** and count if there are multiple subframes that match our profile */
+        if (offset == s->channel[i].decoded_samples &&
+            subframe_len == s->channel[i].subframe_len[cur_subframe]) {
+            total_samples -= s->channel[i].subframe_len[cur_subframe];
+            s->channel[i].decoded_samples +=
+                s->channel[i].subframe_len[cur_subframe];
+            s->channel_indexes_for_cur_subframe[s->channels_for_cur_subframe] = i;
+            ++s->channels_for_cur_subframe;
+        }
+    }
+
+    /** check if the frame will be complete after processing the
+        estimated block */
+    if (!total_samples)
+        s->parsed_all_subframes = 1;
+
+
+    dprintf(s->avctx, "subframe is part of %i channels\n",
+            s->channels_for_cur_subframe);
+
+    /** calculate number of scale factor bands and their offsets */
+    s->table_idx         = av_log2(s->samples_per_frame/subframe_len);
+    s->num_bands         = s->num_sfb[s->table_idx];
+    s->cur_sfb_offsets   = s->sfb_offsets[s->table_idx];
+    cur_subwoofer_cutoff = s->subwoofer_cutoffs[s->table_idx];
+
+    /** configure the decoder for the current subframe */
+    for (i = 0; i < s->channels_for_cur_subframe; i++) {
+        int c = s->channel_indexes_for_cur_subframe[i];
+
+        s->channel[c].coeffs = &s->channel[c].out[(s->samples_per_frame >> 1)
+                                                  + offset];
+    }
+
+    s->subframe_len = subframe_len;
+    s->esc_len = av_log2(s->subframe_len - 1) + 1;
+
+    /** skip extended header if any */
+    if (get_bits1(&s->gb)) {
+        int num_fill_bits;
+        if (!(num_fill_bits = get_bits(&s->gb, 2))) {
+            int len = get_bits(&s->gb, 4);
+            num_fill_bits = get_bits(&s->gb, len) + 1;
+        }
+
+        if (num_fill_bits >= 0) {
+            if (get_bits_count(&s->gb) + num_fill_bits > s->num_saved_bits) {
+                av_log(s->avctx, AV_LOG_ERROR, "invalid number of fill bits\n");
+                return AVERROR_INVALIDDATA;
+            }
+
+            skip_bits_long(&s->gb, num_fill_bits);
+        }
+    }
+
+    /** no idea for what the following bit is used */
+    if (get_bits1(&s->gb)) {
+        ff_log_ask_for_sample(s->avctx, "reserved bit set\n");
+        return AVERROR_INVALIDDATA;
+    }
+
+
+    if (decode_channel_transform(s) < 0)
+        return AVERROR_INVALIDDATA;
+
+
+    for (i = 0; i < s->channels_for_cur_subframe; i++) {
+        int c = s->channel_indexes_for_cur_subframe[i];
+        if ((s->channel[c].transmit_coefs = get_bits1(&s->gb)))
+            transmit_coeffs = 1;
+    }
+
+    if (transmit_coeffs) {
+        int step;
+        int quant_step = 90 * s->bits_per_sample >> 4;
+        if ((get_bits1(&s->gb))) {
+            /** FIXME: might change run level mode decision */
+            ff_log_ask_for_sample(s->avctx, "unsupported quant step coding\n");
+            return AVERROR_INVALIDDATA;
+        }
+        /** decode quantization step */
+        step = get_sbits(&s->gb, 6);
+        quant_step += step;
+        if (step == -32 || step == 31) {
+            const int sign = (step == 31) - 1;
+            int quant = 0;
+            while (get_bits_count(&s->gb) + 5 < s->num_saved_bits &&
+                   (step = get_bits(&s->gb, 5)) == 31) {
+                quant += 31;
+            }
+            quant_step += ((quant + step) ^ sign) - sign;
+        }
+        if (quant_step < 0) {
+            av_log(s->avctx, AV_LOG_DEBUG, "negative quant step\n");
+        }
+
+        /** decode quantization step modifiers for every channel */
+
+        if (s->channels_for_cur_subframe == 1) {
+            s->channel[s->channel_indexes_for_cur_subframe[0]].quant_step = quant_step;
+        } else {
+            int modifier_len = get_bits(&s->gb, 3);
+            for (i = 0; i < s->channels_for_cur_subframe; i++) {
+                int c = s->channel_indexes_for_cur_subframe[i];
+                s->channel[c].quant_step = quant_step;
+                if (get_bits1(&s->gb)) {
+                    if (modifier_len) {
+                        s->channel[c].quant_step += get_bits(&s->gb, modifier_len) + 1;
+                    } else
+                        ++s->channel[c].quant_step;
+                }
+            }
+        }
+
+        /** decode scale factors */
+        if (decode_scale_factors(s) < 0)
+            return AVERROR_INVALIDDATA;
+    }
+
+    dprintf(s->avctx, "BITSTREAM: subframe header length was %i\n",
+            get_bits_count(&s->gb) - s->subframe_offset);
+
+    /** parse coefficients */
+    for (i = 0; i < s->channels_for_cur_subframe; i++) {
+        int c = s->channel_indexes_for_cur_subframe[i];
+        if (s->channel[c].transmit_coefs &&
+            get_bits_count(&s->gb) < s->num_saved_bits) {
+            decode_coeffs(s, c);
+        } else
+            memset(s->channel[c].coeffs, 0,
+                   sizeof(*s->channel[c].coeffs) * subframe_len);
+    }
+
+    dprintf(s->avctx, "BITSTREAM: subframe length was %i\n",
+            get_bits_count(&s->gb) - s->subframe_offset);
+
+    if (transmit_coeffs) {
+        /** reconstruct the per channel data */
+        inverse_channel_transform(s);
+        for (i = 0; i < s->channels_for_cur_subframe; i++) {
+            int c = s->channel_indexes_for_cur_subframe[i];
+            const int* sf = s->channel[c].scale_factors;
+            int b;
+
+            if (c == s->lfe_channel)
+                memset(&s->tmp[cur_subwoofer_cutoff], 0, sizeof(*s->tmp) *
+                       (subframe_len - cur_subwoofer_cutoff));
+
+            /** inverse quantization and rescaling */
+            for (b = 0; b < s->num_bands; b++) {
+                const int end = FFMIN(s->cur_sfb_offsets[b+1], s->subframe_len);
+                const int exp = s->channel[c].quant_step -
+                            (s->channel[c].max_scale_factor - *sf++) *
+                            s->channel[c].scale_factor_step;
+                const float quant = pow(10.0, exp / 20.0);
+                int start = s->cur_sfb_offsets[b];
+                s->dsp.vector_fmul_scalar(s->tmp + start,
+                                          s->channel[c].coeffs + start,
+                                          quant, end - start);
+            }
+
+            /** apply imdct (ff_imdct_half == DCTIV with reverse) */
+            ff_imdct_half(&s->mdct_ctx[av_log2(subframe_len) - BLOCK_MIN_BITS],
+                          s->channel[c].coeffs, s->tmp);
+        }
+    }
+
+    /** window and overlapp-add */
+    wmapro_window(s);
+
+    /** handled one subframe */
+    for (i = 0; i < s->channels_for_cur_subframe; i++) {
+        int c = s->channel_indexes_for_cur_subframe[i];
+        if (s->channel[c].cur_subframe >= s->channel[c].num_subframes) {
+            av_log(s->avctx, AV_LOG_ERROR, "broken subframe\n");
+            return AVERROR_INVALIDDATA;
+        }
+        ++s->channel[c].cur_subframe;
+    }
+
+    return 0;
+}
+
+/**
+ *@brief Decode one WMA frame.
+ *@param s codec context
+ *@return 0 if the trailer bit indicates that this is the last frame,
+ *        1 if there are additional frames
+ */
+static int decode_frame(WMAProDecodeCtx *s)
+{
+    GetBitContext* gb = &s->gb;
+    int more_frames = 0;
+    int len = 0;
+    int i;
+
+    /** check for potential output buffer overflow */
+    if (s->num_channels * s->samples_per_frame > s->samples_end - s->samples) {
+        /** return an error if no frame could be decoded at all */
+        av_log(s->avctx, AV_LOG_ERROR,
+               "not enough space for the output samples\n");
+        s->packet_loss = 1;
+        return 0;
+    }
+
+    /** get frame length */
+    if (s->len_prefix)
+        len = get_bits(gb, s->log2_frame_size);
+
+    dprintf(s->avctx, "decoding frame with length %x\n", len);
+
+    /** decode tile information */
+    if (decode_tilehdr(s)) {
+        s->packet_loss = 1;
+        return 0;
+    }
+
+    /** read postproc transform */
+    if (s->num_channels > 1 && get_bits1(gb)) {
+        ff_log_ask_for_sample(s->avctx, "Unsupported postproc transform found\n");
+        s->packet_loss = 1;
+        return 0;
+    }
+
+    /** read drc info */
+    if (s->dynamic_range_compression) {
+        s->drc_gain = get_bits(gb, 8);
+        dprintf(s->avctx, "drc_gain %i\n", s->drc_gain);
+    }
+
+    /** no idea what these are for, might be the number of samples
+        that need to be skipped at the beginning or end of a stream */
+    if (get_bits1(gb)) {
+        int skip;
+
+        /** usually true for the first frame */
+        if (get_bits1(gb)) {
+            skip = get_bits(gb, av_log2(s->samples_per_frame * 2));
+            dprintf(s->avctx, "start skip: %i\n", skip);
+        }
+
+        /** sometimes true for the last frame */
+        if (get_bits1(gb)) {
+            skip = get_bits(gb, av_log2(s->samples_per_frame * 2));
+            dprintf(s->avctx, "end skip: %i\n", skip);
+        }
+
+    }
+
+    dprintf(s->avctx, "BITSTREAM: frame header length was %i\n",
+            get_bits_count(gb) - s->frame_offset);
+
+    /** reset subframe states */
+    s->parsed_all_subframes = 0;
+    for (i = 0; i < s->num_channels; i++) {
+        s->channel[i].decoded_samples = 0;
+        s->channel[i].cur_subframe    = 0;
+        s->channel[i].reuse_sf        = 0;
+    }
+
+    /** decode all subframes */
+    while (!s->parsed_all_subframes) {
+        if (decode_subframe(s) < 0) {
+            s->packet_loss = 1;
+            return 0;
+        }
+    }
+
+    /** interleave samples and write them to the output buffer */
+    for (i = 0; i < s->num_channels; i++) {
+        float* ptr;
+        int incr = s->num_channels;
+        float* iptr = s->channel[i].out;
+        int x;
+
+        ptr = s->samples + i;
+
+        for (x = 0; x < s->samples_per_frame; x++) {
+            *ptr = av_clipf(*iptr++, -1.0, 32767.0 / 32768.0);
+            ptr += incr;
+        }
+
+        /** reuse second half of the IMDCT output for the next frame */
+        memcpy(&s->channel[i].out[0],
+               &s->channel[i].out[s->samples_per_frame],
+               s->samples_per_frame * sizeof(*s->channel[i].out) >> 1);
+    }
+
+    if (s->skip_frame) {
+        s->skip_frame = 0;
+    } else
+        s->samples += s->num_channels * s->samples_per_frame;
+
+    if (len != (get_bits_count(gb) - s->frame_offset) + 2) {
+        /** FIXME: not sure if this is always an error */
+        av_log(s->avctx, AV_LOG_ERROR, "frame[%i] would have to skip %i bits\n",
+               s->frame_num, len - (get_bits_count(gb) - s->frame_offset) - 1);
+        s->packet_loss = 1;
+        return 0;
+    }
+
+    /** skip the rest of the frame data */
+    skip_bits_long(gb, len - (get_bits_count(gb) - s->frame_offset) - 1);
+
+    /** decode trailer bit */
+    more_frames = get_bits1(gb);
+
+    ++s->frame_num;
+    return more_frames;
+}
+
+/**
+ *@brief Calculate remaining input buffer length.
+ *@param s codec context
+ *@param gb bitstream reader context
+ *@return remaining size in bits
+ */
+static int remaining_bits(WMAProDecodeCtx *s, GetBitContext *gb)
+{
+    return s->buf_bit_size - get_bits_count(gb);
+}
+
+/**
+ *@brief Fill the bit reservoir with a (partial) frame.
+ *@param s codec context
+ *@param gb bitstream reader context
+ *@param len length of the partial frame
+ *@param append decides wether to reset the buffer or not
+ */
+static void save_bits(WMAProDecodeCtx *s, GetBitContext* gb, int len,
+                      int append)
+{
+    int buflen;
+
+    /** when the frame data does not need to be concatenated, the input buffer
+        is resetted and additional bits from the previous frame are copyed
+        and skipped later so that a fast byte copy is possible */
+
+    if (!append) {
+        s->frame_offset = get_bits_count(gb) & 7;
+        s->num_saved_bits = s->frame_offset;
+        init_put_bits(&s->pb, s->frame_data, MAX_FRAMESIZE);
+    }
+
+    buflen = (s->num_saved_bits + len + 8) >> 3;
+
+    if (len <= 0 || buflen > MAX_FRAMESIZE) {
+        ff_log_ask_for_sample(s->avctx, "input buffer too small\n");
+        s->packet_loss = 1;
+        return;
+    }
+
+    s->num_saved_bits += len;
+    if (!append) {
+        ff_copy_bits(&s->pb, gb->buffer + (get_bits_count(gb) >> 3),
+                     s->num_saved_bits);
+    } else {
+        int align = 8 - (get_bits_count(gb) & 7);
+        align = FFMIN(align, len);
+        put_bits(&s->pb, align, get_bits(gb, align));
+        len -= align;
+        ff_copy_bits(&s->pb, gb->buffer + (get_bits_count(gb) >> 3), len);
+    }
+    skip_bits_long(gb, len);
+
+    {
+        PutBitContext tmp = s->pb;
+        flush_put_bits(&tmp);
+    }
+
+    init_get_bits(&s->gb, s->frame_data, s->num_saved_bits);
+    skip_bits(&s->gb, s->frame_offset);
+}
+
+/**
+ *@brief Decode a single WMA packet.
+ *@param avctx codec context
+ *@param data the output buffer
+ *@param data_size number of bytes that were written to the output buffer
+ *@param buf input buffer
+ *@param buf_size input buffer length 
+ *@return number of bytes that were read from the input buffer
+ */
+static int decode_packet(AVCodecContext *avctx,
+                         void *data, int *data_size,
+                         const uint8_t *buf, int buf_size)
+{
+    WMAProDecodeCtx *s = avctx->priv_data;
+    GetBitContext* gb  = &s->pgb;
+    int num_bits_prev_frame;
+    int packet_sequence_number;
+
+    s->samples       = data;
+    s->samples_end   = (float*)((int8_t*)data + *data_size);
+    *data_size = 0;
+
+    if (s->packet_done || s->packet_loss) {
+        s->packet_done = 0;
+        s->buf_bit_size = buf_size << 3;
+
+        /** sanity check for the buffer length */
+        if (buf_size < avctx->block_align)
+            return 0;
+
+        buf_size = avctx->block_align;
+
+        /** parse packet header */
+        init_get_bits(gb, buf, s->buf_bit_size);
+        packet_sequence_number = get_bits(gb, 4);
+        skip_bits(gb, 2);
+
+        /** get number of bits that need to be added to the previous frame */
+        num_bits_prev_frame = get_bits(gb, s->log2_frame_size);
+        dprintf(avctx, "packet[%d]: nbpf %x\n", avctx->frame_number,
+                num_bits_prev_frame);
+
+        /** check for packet loss */
+        if (!s->packet_loss &&
+            ((s->packet_sequence_number + 1) & 0xF) != packet_sequence_number) {
+            s->packet_loss = 1;
+            av_log(avctx, AV_LOG_ERROR, "Packet loss detected! seq %x vs %x\n",
+                   s->packet_sequence_number, packet_sequence_number);
+        }
+        s->packet_sequence_number = packet_sequence_number;
+
+        if (num_bits_prev_frame > 0) {
+            /** append the previous frame data to the remaining data from the
+                previous packet to create a full frame */
+            save_bits(s, gb, num_bits_prev_frame, 1);
+            dprintf(avctx, "accumulated %x bits of frame data\n",
+                    s->num_saved_bits - s->frame_offset);
+
+            /** decode the cross packet frame if it is valid */
+            if (!s->packet_loss)
+                decode_frame(s);
+        } else if (s->num_saved_bits - s->frame_offset) {
+            dprintf(avctx, "ignoring %x previously saved bits\n",
+                    s->num_saved_bits - s->frame_offset);
+        }
+
+        s->packet_loss = 0;
+
+    } else {
+        int frame_size;
+        s->buf_bit_size = buf_size << 3;
+        init_get_bits(gb, buf, s->buf_bit_size);
+        skip_bits(gb, s->packet_offset);
+        if (remaining_bits(s, gb) > s->log2_frame_size &&
+            (frame_size = show_bits(gb, s->log2_frame_size)) &&
+            frame_size <= remaining_bits(s, gb)) {
+            save_bits(s, gb, frame_size, 0);
+            s->packet_done = !decode_frame(s);
+        } else
+            s->packet_done = 1;
+    }
+
+    if (s->packet_done && !s->packet_loss &&
+        remaining_bits(s, gb) > 0) {
+        /** save the rest of the data so that it can be decoded
+            with the next packet */
+        save_bits(s, gb, remaining_bits(s, gb), 0);
+    }
+
+    *data_size = (int8_t *)s->samples - (int8_t *)data;
+    s->packet_offset = get_bits_count(gb) & 7;
+
+    return (s->packet_loss) ? AVERROR_INVALIDDATA : get_bits_count(gb) >> 3;
+}
+
+/**
+ *@brief Clear decoder buffers (for seeking).
+ *@param avctx codec context
+ */
+static void flush(AVCodecContext *avctx)
+{
+    WMAProDecodeCtx *s = avctx->priv_data;
+    int i;
+    /** reset output buffer as a part of it is used during the windowing of a
+        new frame */
+    for (i = 0; i < s->num_channels; i++)
+        memset(s->channel[i].out, 0, s->samples_per_frame *
+               sizeof(*s->channel[i].out));
+    s->packet_loss = 1;
+}
+
+
+/**
+ *@brief wmapro decoder
+ */
+AVCodec wmapro_decoder = {
+    "wmapro",
+    CODEC_TYPE_AUDIO,
+    CODEC_ID_WMAPRO,
+    sizeof(WMAProDecodeCtx),
+    decode_init,
+    NULL,
+    decode_end,
+    decode_packet,
+    .flush= flush,
+    .long_name = NULL_IF_CONFIG_SMALL("Windows Media Audio 9 Professional"),
+};

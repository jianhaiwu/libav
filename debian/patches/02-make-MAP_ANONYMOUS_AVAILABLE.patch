Author: Colin Watson <cjwatson@ubuntu.com>
Description: make MAP_ANONYMOUS available on Linux and the Hurd
Forwarded: http://bugzilla.libav.org/show_bug.cgi?id=36


On a modern GNU/Linux system (specifically the current Ubuntu
development branch), hyscale_fast_MMX2 segfaults.  My test case was as
follows:

  $ ./configure --disable-avfilter --enable-libtheora --enable-libvorbis && make && make libswscale/swscale-test
  $ gdb libswscale/swscale-test
  [...]
  (gdb) r
  Starting program: /home/cjwatson/src/libav/libav/libswscale/swscale-test
  [Thread debugging using libthread_db enabled]
  yuv420p -> yuv420p
   yuv420p 96x96 -> yuv420p  64x 64 flags= 1 CRC=0c6d2001 SSD=    3,   14,   15,    0
   yuv420p 96x96 -> yuv420p  64x 96 flags= 1 CRC=3ab542d8 SSD=    4,   14,   16,    0
   yuv420p 96x96 -> yuv420p  64x128 flags= 1 CRC=0374f12b SSD=    3,   13,   15,    0
   yuv420p 96x96 -> yuv420p  96x 64 flags= 1
  Program received signal SIGSEGV, Segmentation fault.
  0x0807b24f in hyscale_fast_MMX2 (c=0x80a8060, dst=0x809ee60, dstWidth=96,
      src=0x8096020 "\200\200\200\200\200\200\202\206\212\215\221\225\231\235\241\244\250\254\251\237\225\213\201wndZPF<9=AEIMRVZ^bfgeb`^[YWTRPMPYajs{\204\214\225\236\246\257\261\256\253\250\244\241\236\233\227\224\221\216\214\213\212\212\211\210\210\207\206\206\205\204\204\204\204\204\204\204\200\200\200\200\200\200\202\206\212\215\221\225\231\235\241\244\250\254\251\237\225\213\201wndZPF<9=AEIMRVZ^bfgeb`^[YWTRPMPYajs{\204\214\225\236\246\257\261\256\253\250\244\241\236\233\227\224\221\216\214\213\212\212\211\210\210\207\206\206\205\204\204\204\204\204\204\204\200\200\200\200\200\200\202\206"..., srcW=96, xInc=65556)
      at libswscale/x86/swscale_template.c:2132
  2132        __asm__ volatile(
  (gdb) disas /r
  Dump of assembler code for function hyscale_fast_MMX2:
     0x0807b200 <+0>:     55      push   %ebp
     0x0807b201 <+1>:     57      push   %edi
     0x0807b202 <+2>:     56      push   %esi
     0x0807b203 <+3>:     53      push   %ebx
     0x0807b204 <+4>:     83 ec 10        sub    $0x10,%esp
     0x0807b207 <+7>:     8b 44 24 24     mov    0x24(%esp),%eax
     0x0807b20b <+11>:    8b 6c 24 38     mov    0x38(%esp),%ebp
     0x0807b20f <+15>:    8b 90 b0 08 00 00       mov    0x8b0(%eax),%edx
     0x0807b215 <+21>:    89 54 24 04     mov    %edx,0x4(%esp)
     0x0807b219 <+25>:    8b 90 a0 08 00 00       mov    0x8a0(%eax),%edx
     0x0807b21f <+31>:    8b 80 d8 08 00 00       mov    0x8d8(%eax),%eax
     0x0807b225 <+37>:    89 54 24 08     mov    %edx,0x8(%esp)
     0x0807b229 <+41>:    89 44 24 0c     mov    %eax,0xc(%esp)
     0x0807b22d <+45>:    0f ef ff        pxor   %mm7,%mm7
     0x0807b230 <+48>:    8b 4c 24 30     mov    0x30(%esp),%ecx
     0x0807b234 <+52>:    8b 7c 24 28     mov    0x28(%esp),%edi
     0x0807b238 <+56>:    8b 54 24 08     mov    0x8(%esp),%edx
     0x0807b23c <+60>:    8b 5c 24 04     mov    0x4(%esp),%ebx
     0x0807b240 <+64>:    31 c0   xor    %eax,%eax
     0x0807b242 <+66>:    0f 18 01        prefetchnta (%ecx)
     0x0807b245 <+69>:    0f 18 41 20     prefetchnta 0x20(%ecx)
     0x0807b249 <+73>:    0f 18 41 40     prefetchnta 0x40(%ecx)
     0x0807b24d <+77>:    8b 33   mov    (%ebx),%esi
  => 0x0807b24f <+79>:    ff 54 24 0c     call   *0xc(%esp)

This is because the region of memory where SwsContext.lumMmx2FilterCode
is stored is not marked executable, which is because sws_init_context is
falling back to plain av_malloc to allocate that memory rather than
using mmap/mprotect, which in turn is because neither _BSD_SOURCE nor
_SVID_SOURCE is defined on this platform following
046f081b46c8479820409cf8f530b988221bd15b.

-D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 isn't sufficient to get
MAP_ANONYMOUS; glibc guards that definition with #ifdef __USE_MISC,
which <features.h> defines only #if defined _BSD_SOURCE || defined
_SVID_SOURCE.

This patch adds -D_BSD_SOURCE on this platform to avoid this.
-D_SVID_SOURCE would probably work too but I didn't test that.  I went
for -D_BSD_SOURCE since that's already used on GNU/kFreeBSD, and
matching a platform with the same C library makes sense to me.


--- a/configure
+++ b/configure
@@ -2469,7 +2469,7 @@ case $target_os in
         add_cppflags -U__STRICT_ANSI__
         ;;
     linux)
-        add_cppflags -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600
+        add_cppflags -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -D_BSD_SOURCE
         enable dv1394
         ;;
     irix*)
@@ -2504,7 +2504,7 @@ case $target_os in
         add_cppflags -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -D_BSD_SOURCE
         ;;
     gnu)
-        add_cppflags -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600
+        add_cppflags -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -D_BSD_SOURCE
         ;;
     qnx)
         add_cppflags -D_QNX_SOURCE

From 991e6fa35b4ad2df389ba7e1c2c58d064e295c76 Mon Sep 17 00:00:00 2001
From: Anssi Hannula <anssi.hannula@iki.fi>
Date: Thu, 6 Mar 2014 18:40:00 +0100
Subject: [PATCH 09/14] http: Add support for selecting a request range
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Comment from Reimar DÃ¶ffinger included as pro memoria.

Signed-off-by: Luca Barbato <lu_zero@gentoo.org>
(cherry picked from commit 2ec33d27127251bbc45e1f88e60691ad59cf2319)
---
 doc/protocols.texi |    6 ++++++
 libavformat/http.c |   17 ++++++++++++++---
 2 files changed, 20 insertions(+), 3 deletions(-)

diff --git a/doc/protocols.texi b/doc/protocols.texi
index fa14a8c..406a431 100644
--- a/doc/protocols.texi
+++ b/doc/protocols.texi
@@ -114,6 +114,12 @@ If the server supports ICY metadata, and @option{icy} was set to 1, this
 contains the last non-empty metadata packet sent by the server. It should be
 polled in regular intervals by applications interested in mid-stream metadata
 updates.
+
+@item offset
+Set initial byte offset.
+
+@item end_offset
+Try to limit the request to bytes preceding this offset.
 @end table
 
 @section mmst
diff --git a/libavformat/http.c b/libavformat/http.c
index a2fd439..54910a9 100644
--- a/libavformat/http.c
+++ b/libavformat/http.c
@@ -51,7 +51,7 @@ typedef struct {
     int http_code;
     /* Used if "Transfer-Encoding: chunked" otherwise -1. */
     int64_t chunksize;
-    int64_t off, filesize;
+    int64_t off, end_off, filesize;
     char *location;
     HTTPAuthState auth_state;
     HTTPAuthState proxy_auth_state;
@@ -106,6 +106,8 @@ static const AVOption options[] = {
 {"basic", "HTTP basic authentication", 0, AV_OPT_TYPE_CONST, {.i64 = HTTP_AUTH_BASIC}, 0, 0, D|E, "auth_type" },
 {"send_expect_100", "Force sending an Expect: 100-continue header for POST", OFFSET(send_expect_100), AV_OPT_TYPE_INT, {.i64 = 0}, 0, 1, E },
 {"location", "The actual location of the data received", OFFSET(location), AV_OPT_TYPE_STRING, { 0 }, 0, 0, D|E },
+{"offset", "initial byte offset", OFFSET(off), AV_OPT_TYPE_INT64, {.i64 = 0}, 0, INT64_MAX, D },
+{"end_offset", "try to limit the request to bytes preceding this offset", OFFSET(end_off), AV_OPT_TYPE_INT64, {.i64 = 0}, 0, INT64_MAX, D },
 {NULL}
 };
 #define HTTP_CLASS(flavor)\
@@ -571,9 +573,18 @@ static int http_connect(URLContext *h, const char *path, const char *local_path,
     if (!has_header(s->headers, "\r\nAccept: "))
         len += av_strlcpy(headers + len, "Accept: */*\r\n",
                           sizeof(headers) - len);
-    if (!has_header(s->headers, "\r\nRange: ") && !post)
+    // Note: we send this on purpose even when s->off is 0 when we're probing,
+    // since it allows us to detect more reliably if a (non-conforming)
+    // server supports seeking by analysing the reply headers.
+    if (!has_header(s->headers, "\r\nRange: ") && !post) {
         len += av_strlcatf(headers + len, sizeof(headers) - len,
-                           "Range: bytes=%"PRId64"-\r\n", s->off);
+                           "Range: bytes=%"PRId64"-", s->off);
+        if (s->end_off)
+            len += av_strlcatf(headers + len, sizeof(headers) - len,
+                               "%"PRId64, s->end_off - 1);
+        len += av_strlcpy(headers + len, "\r\n",
+                          sizeof(headers) - len);
+    }
     if (send_expect_100 && !has_header(s->headers, "\r\nExpect: "))
         len += av_strlcatf(headers + len, sizeof(headers) - len,
                            "Expect: 100-continue\r\n");
-- 
1.7.10.4


From 2ed40608e9499de7ed6bd4bd61cc50645ec6d8a4 Mon Sep 17 00:00:00 2001
From: Justin Ruggles <justin.ruggles@gmail.com>
Date: Tue, 23 Oct 2012 16:30:59 -0400
Subject: [PATCH 146/278] wma: do not keep private copies of some
 AVCodecContext fields

channels, sample_rate, bit_rate, and block_align can be used directly from
the AVCodecContext
---
 libavcodec/wma.c    |   36 ++++++++++++++++--------------------
 libavcodec/wma.h    |    4 ----
 libavcodec/wmadec.c |   34 +++++++++++++++++-----------------
 libavcodec/wmaenc.c |   30 +++++++++++++++---------------
 4 files changed, 48 insertions(+), 56 deletions(-)

diff --git a/libavcodec/wma.c b/libavcodec/wma.c
index f9ba9c3..9808a16 100644
--- a/libavcodec/wma.c
+++ b/libavcodec/wma.c
@@ -82,11 +82,6 @@ int ff_wma_init(AVCodecContext *avctx, int flags2)
         || avctx->bit_rate    <= 0)
         return -1;
 
-    s->sample_rate = avctx->sample_rate;
-    s->nb_channels = avctx->channels;
-    s->bit_rate    = avctx->bit_rate;
-    s->block_align = avctx->block_align;
-
     ff_dsputil_init(&s->dsp, avctx);
     ff_fmt_convert_init(&s->fmt_conv, avctx);
     avpriv_float_dsp_init(&s->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);
@@ -98,7 +93,8 @@ int ff_wma_init(AVCodecContext *avctx, int flags2)
     }
 
     /* compute MDCT block size */
-    s->frame_len_bits = ff_wma_get_frame_len_bits(s->sample_rate, s->version, 0);
+    s->frame_len_bits = ff_wma_get_frame_len_bits(avctx->sample_rate,
+                                                  s->version, 0);
     s->next_block_len_bits = s->frame_len_bits;
     s->prev_block_len_bits = s->frame_len_bits;
     s->block_len_bits      = s->frame_len_bits;
@@ -107,7 +103,7 @@ int ff_wma_init(AVCodecContext *avctx, int flags2)
     if (s->use_variable_block_len) {
         int nb_max, nb;
         nb = ((flags2 >> 3) & 3) + 1;
-        if ((s->bit_rate / s->nb_channels) >= 32000)
+        if ((avctx->bit_rate / avctx->channels) >= 32000)
             nb += 2;
         nb_max = s->frame_len_bits - BLOCK_MIN_BITS;
         if (nb > nb_max)
@@ -119,10 +115,10 @@ int ff_wma_init(AVCodecContext *avctx, int flags2)
 
     /* init rate dependent parameters */
     s->use_noise_coding = 1;
-    high_freq = s->sample_rate * 0.5;
+    high_freq = avctx->sample_rate * 0.5;
 
     /* if version 2, then the rates are normalized */
-    sample_rate1 = s->sample_rate;
+    sample_rate1 = avctx->sample_rate;
     if (s->version == 2) {
         if (sample_rate1 >= 44100) {
             sample_rate1 = 44100;
@@ -137,13 +133,13 @@ int ff_wma_init(AVCodecContext *avctx, int flags2)
         }
     }
 
-    bps = (float)s->bit_rate / (float)(s->nb_channels * s->sample_rate);
+    bps = (float)avctx->bit_rate / (float)(avctx->channels * avctx->sample_rate);
     s->byte_offset_bits = av_log2((int)(bps * s->frame_len / 8.0 + 0.5)) + 2;
 
     /* compute high frequency value and choose if noise coding should
        be activated */
     bps1 = bps;
-    if (s->nb_channels == 2)
+    if (avctx->channels == 2)
         bps1 = bps * 1.6;
     if (sample_rate1 == 44100) {
         if (bps1 >= 0.61) {
@@ -186,8 +182,8 @@ int ff_wma_init(AVCodecContext *avctx, int flags2)
     }
     av_dlog(s->avctx, "flags2=0x%x\n", flags2);
     av_dlog(s->avctx, "version=%d channels=%d sample_rate=%d bitrate=%d block_align=%d\n",
-            s->version, s->nb_channels, s->sample_rate, s->bit_rate,
-            s->block_align);
+            s->version, avctx->channels, avctx->sample_rate, avctx->bit_rate,
+            avctx->block_align);
     av_dlog(s->avctx, "bps=%f bps1=%f high_freq=%f bitoffset=%d\n",
             bps, bps1, high_freq, s->byte_offset_bits);
     av_dlog(s->avctx, "use_noise_coding=%d use_exp_vlc=%d nb_block_sizes=%d\n",
@@ -210,7 +206,7 @@ int ff_wma_init(AVCodecContext *avctx, int flags2)
                 lpos = 0;
                 for (i = 0; i < 25; i++) {
                     a = ff_wma_critical_freqs[i];
-                    b = s->sample_rate;
+                    b = avctx->sample_rate;
                     pos = ((block_len * 2 * a) + (b >> 1)) / b;
                     if (pos > block_len)
                         pos = block_len;
@@ -227,11 +223,11 @@ int ff_wma_init(AVCodecContext *avctx, int flags2)
                 table = NULL;
                 a = s->frame_len_bits - BLOCK_MIN_BITS - k;
                 if (a < 3) {
-                    if (s->sample_rate >= 44100) {
+                    if (avctx->sample_rate >= 44100) {
                         table = exponent_band_44100[a];
-                    } else if (s->sample_rate >= 32000) {
+                    } else if (avctx->sample_rate >= 32000) {
                         table = exponent_band_32000[a];
-                    } else if (s->sample_rate >= 22050) {
+                    } else if (avctx->sample_rate >= 22050) {
                         table = exponent_band_22050[a];
                     }
                 }
@@ -245,7 +241,7 @@ int ff_wma_init(AVCodecContext *avctx, int flags2)
                     lpos = 0;
                     for (i = 0; i < 25; i++) {
                         a = ff_wma_critical_freqs[i];
-                        b = s->sample_rate;
+                        b = avctx->sample_rate;
                         pos = ((block_len * 2 * a) + (b << 1)) / (4 * b);
                         pos <<= 2;
                         if (pos > block_len)
@@ -264,7 +260,7 @@ int ff_wma_init(AVCodecContext *avctx, int flags2)
             s->coefs_end[k] = (s->frame_len - ((s->frame_len * 9) / 100)) >> k;
             /* high freq computation */
             s->high_band_start[k] = (int)((block_len * 2 * high_freq) /
-                                          s->sample_rate + 0.5);
+                                          avctx->sample_rate + 0.5);
             n = s->exponent_sizes[k];
             j = 0;
             pos = 0;
@@ -344,7 +340,7 @@ int ff_wma_init(AVCodecContext *avctx, int flags2)
 
     /* choose the VLC tables for the coefficients */
     coef_vlc_table = 2;
-    if (s->sample_rate >= 32000) {
+    if (avctx->sample_rate >= 32000) {
         if (bps1 < 0.72) {
             coef_vlc_table = 0;
         } else if (bps1 < 1.16) {
diff --git a/libavcodec/wma.h b/libavcodec/wma.h
index f81e095..fb2aa8b 100644
--- a/libavcodec/wma.h
+++ b/libavcodec/wma.h
@@ -69,11 +69,7 @@ typedef struct WMACodecContext {
     AVFrame frame;
     GetBitContext gb;
     PutBitContext pb;
-    int sample_rate;
-    int nb_channels;
-    int bit_rate;
     int version;                            ///< 1 = 0x160 (WMAV1), 2 = 0x161 (WMAV2)
-    int block_align;
     int use_bit_reservoir;
     int use_variable_block_len;
     int use_exp_vlc;                        ///< exponent coding: 0 = lsp, 1 = vlc + delta
diff --git a/libavcodec/wmadec.c b/libavcodec/wmadec.c
index bbb8402..eb7fe7c 100644
--- a/libavcodec/wmadec.c
+++ b/libavcodec/wmadec.c
@@ -475,11 +475,11 @@ static int wma_decode_block(WMACodecContext *s)
         return -1;
     }
 
-    if (s->nb_channels == 2) {
+    if (s->avctx->channels == 2) {
         s->ms_stereo = get_bits1(&s->gb);
     }
     v = 0;
-    for(ch = 0; ch < s->nb_channels; ch++) {
+    for(ch = 0; ch < s->avctx->channels; ch++) {
         a = get_bits1(&s->gb);
         s->channel_coded[ch] = a;
         v |= a;
@@ -506,13 +506,13 @@ static int wma_decode_block(WMACodecContext *s)
 
     /* compute number of coefficients */
     n = s->coefs_end[bsize] - s->coefs_start;
-    for(ch = 0; ch < s->nb_channels; ch++)
+    for(ch = 0; ch < s->avctx->channels; ch++)
         nb_coefs[ch] = n;
 
     /* complex coding */
     if (s->use_noise_coding) {
 
-        for(ch = 0; ch < s->nb_channels; ch++) {
+        for(ch = 0; ch < s->avctx->channels; ch++) {
             if (s->channel_coded[ch]) {
                 int i, n, a;
                 n = s->exponent_high_sizes[bsize];
@@ -525,7 +525,7 @@ static int wma_decode_block(WMACodecContext *s)
                 }
             }
         }
-        for(ch = 0; ch < s->nb_channels; ch++) {
+        for(ch = 0; ch < s->avctx->channels; ch++) {
             if (s->channel_coded[ch]) {
                 int i, n, val, code;
 
@@ -553,7 +553,7 @@ static int wma_decode_block(WMACodecContext *s)
     /* exponents can be reused in short blocks. */
     if ((s->block_len_bits == s->frame_len_bits) ||
         get_bits1(&s->gb)) {
-        for(ch = 0; ch < s->nb_channels; ch++) {
+        for(ch = 0; ch < s->avctx->channels; ch++) {
             if (s->channel_coded[ch]) {
                 if (s->use_exp_vlc) {
                     if (decode_exp_vlc(s, ch) < 0)
@@ -567,7 +567,7 @@ static int wma_decode_block(WMACodecContext *s)
     }
 
     /* parse spectral coefficients : just RLE encoding */
-    for(ch = 0; ch < s->nb_channels; ch++) {
+    for (ch = 0; ch < s->avctx->channels; ch++) {
         if (s->channel_coded[ch]) {
             int tindex;
             WMACoef* ptr = &s->coefs1[ch][0];
@@ -581,7 +581,7 @@ static int wma_decode_block(WMACodecContext *s)
                   0, ptr, 0, nb_coefs[ch],
                   s->block_len, s->frame_len_bits, coef_nb_bits);
         }
-        if (s->version == 1 && s->nb_channels >= 2) {
+        if (s->version == 1 && s->avctx->channels >= 2) {
             align_get_bits(&s->gb);
         }
     }
@@ -596,7 +596,7 @@ static int wma_decode_block(WMACodecContext *s)
     }
 
     /* finally compute the MDCT coefficients */
-    for(ch = 0; ch < s->nb_channels; ch++) {
+    for (ch = 0; ch < s->avctx->channels; ch++) {
         if (s->channel_coded[ch]) {
             WMACoef *coefs1;
             float *coefs, *exponents, mult, mult1, noise;
@@ -700,7 +700,7 @@ static int wma_decode_block(WMACodecContext *s)
     }
 
 #ifdef TRACE
-    for(ch = 0; ch < s->nb_channels; ch++) {
+    for (ch = 0; ch < s->avctx->channels; ch++) {
         if (s->channel_coded[ch]) {
             dump_floats(s, "exponents", 3, s->exponents[ch], s->block_len);
             dump_floats(s, "coefs", 1, s->coefs[ch], s->block_len);
@@ -724,7 +724,7 @@ static int wma_decode_block(WMACodecContext *s)
 next:
     mdct = &s->mdct_ctx[bsize];
 
-    for(ch = 0; ch < s->nb_channels; ch++) {
+    for (ch = 0; ch < s->avctx->channels; ch++) {
         int n4, index;
 
         n4 = s->block_len / 2;
@@ -768,7 +768,7 @@ static int wma_decode_frame(WMACodecContext *s, float **samples,
             break;
     }
 
-    for (ch = 0; ch < s->nb_channels; ch++) {
+    for (ch = 0; ch < s->avctx->channels; ch++) {
         /* copy current block to output */
         memcpy(samples[ch] + samples_offset, s->frame_out[ch],
                s->frame_len * sizeof(*s->frame_out[ch]));
@@ -801,13 +801,13 @@ static int wma_decode_superframe(AVCodecContext *avctx, void *data,
         s->last_superframe_len = 0;
         return 0;
     }
-    if (buf_size < s->block_align) {
+    if (buf_size < avctx->block_align) {
         av_log(avctx, AV_LOG_ERROR,
                "Input packet size too small (%d < %d)\n",
-               buf_size, s->block_align);
+               buf_size, avctx->block_align);
         return AVERROR_INVALIDDATA;
     }
-    buf_size = s->block_align;
+    buf_size = avctx->block_align;
 
     init_get_bits(&s->gb, buf, buf_size*8);
 
@@ -902,12 +902,12 @@ static int wma_decode_superframe(AVCodecContext *avctx, void *data,
 
     av_dlog(s->avctx, "%d %d %d %d outbytes:%td eaten:%d\n",
             s->frame_len_bits, s->block_len_bits, s->frame_len, s->block_len,
-            (int8_t *)samples - (int8_t *)data, s->block_align);
+            (int8_t *)samples - (int8_t *)data, avctx->block_align);
 
     *got_frame_ptr   = 1;
     *(AVFrame *)data = s->frame;
 
-    return s->block_align;
+    return avctx->block_align;
  fail:
     /* when error, we reset the bit reservoir */
     s->last_superframe_len = 0;
diff --git a/libavcodec/wmaenc.c b/libavcodec/wmaenc.c
index 8abb55b..13d8a1c 100644
--- a/libavcodec/wmaenc.c
+++ b/libavcodec/wmaenc.c
@@ -29,7 +29,7 @@
 
 static int encode_init(AVCodecContext * avctx){
     WMACodecContext *s = avctx->priv_data;
-    int i, flags1, flags2;
+    int i, flags1, flags2, block_align;
     uint8_t *extradata;
 
     s->avctx = avctx;
@@ -80,10 +80,10 @@ static int encode_init(AVCodecContext * avctx){
     for(i = 0; i < s->nb_block_sizes; i++)
         ff_mdct_init(&s->mdct_ctx[i], s->frame_len_bits - i + 1, 0, 1.0);
 
-    s->block_align     = avctx->bit_rate * (int64_t)s->frame_len /
+    block_align        = avctx->bit_rate * (int64_t)s->frame_len /
                          (avctx->sample_rate * 8);
-    s->block_align     = FFMIN(s->block_align, MAX_CODED_SUPERFRAME_SIZE);
-    avctx->block_align = s->block_align;
+    block_align        = FFMIN(block_align, MAX_CODED_SUPERFRAME_SIZE);
+    avctx->block_align = block_align;
     avctx->bit_rate    = avctx->block_align * 8LL * avctx->sample_rate /
                          s->frame_len;
     avctx->frame_size = avctx->delay = s->frame_len;
@@ -188,7 +188,7 @@ static int encode_block(WMACodecContext *s, float (*src_coefs)[BLOCK_MAX_SIZE],
 
     //FIXME factor
     v = s->coefs_end[bsize] - s->coefs_start;
-    for(ch = 0; ch < s->nb_channels; ch++)
+    for (ch = 0; ch < s->avctx->channels; ch++)
         nb_coefs[ch] = v;
     {
         int n4 = s->block_len / 2;
@@ -198,18 +198,18 @@ static int encode_block(WMACodecContext *s, float (*src_coefs)[BLOCK_MAX_SIZE],
         }
     }
 
-    if (s->nb_channels == 2) {
+    if (s->avctx->channels == 2) {
         put_bits(&s->pb, 1, !!s->ms_stereo);
     }
 
-    for(ch = 0; ch < s->nb_channels; ch++) {
+    for (ch = 0; ch < s->avctx->channels; ch++) {
         s->channel_coded[ch] = 1; //FIXME only set channel_coded when needed, instead of always
         if (s->channel_coded[ch]) {
             init_exp(s, ch, fixed_exp);
         }
     }
 
-    for(ch = 0; ch < s->nb_channels; ch++) {
+    for (ch = 0; ch < s->avctx->channels; ch++) {
         if (s->channel_coded[ch]) {
             WMACoef *coefs1;
             float *coefs, *exponents, mult;
@@ -237,7 +237,7 @@ static int encode_block(WMACodecContext *s, float (*src_coefs)[BLOCK_MAX_SIZE],
     }
 
     v = 0;
-    for(ch = 0; ch < s->nb_channels; ch++) {
+    for (ch = 0; ch < s->avctx->channels; ch++) {
         int a = s->channel_coded[ch];
         put_bits(&s->pb, 1, a);
         v |= a;
@@ -253,7 +253,7 @@ static int encode_block(WMACodecContext *s, float (*src_coefs)[BLOCK_MAX_SIZE],
     coef_nb_bits= ff_wma_total_gain_to_bits(total_gain);
 
     if (s->use_noise_coding) {
-        for(ch = 0; ch < s->nb_channels; ch++) {
+        for (ch = 0; ch < s->avctx->channels; ch++) {
             if (s->channel_coded[ch]) {
                 int i, n;
                 n = s->exponent_high_sizes[bsize];
@@ -272,7 +272,7 @@ static int encode_block(WMACodecContext *s, float (*src_coefs)[BLOCK_MAX_SIZE],
     }
 
     if (parse_exponents) {
-        for(ch = 0; ch < s->nb_channels; ch++) {
+        for (ch = 0; ch < s->avctx->channels; ch++) {
             if (s->channel_coded[ch]) {
                 if (s->use_exp_vlc) {
                     encode_exp_vlc(s, ch, fixed_exp);
@@ -286,7 +286,7 @@ static int encode_block(WMACodecContext *s, float (*src_coefs)[BLOCK_MAX_SIZE],
         assert(0); //FIXME not implemented
     }
 
-    for(ch = 0; ch < s->nb_channels; ch++) {
+    for (ch = 0; ch < s->avctx->channels; ch++) {
         if (s->channel_coded[ch]) {
             int run, tindex;
             WMACoef *ptr, *eptr;
@@ -324,7 +324,7 @@ static int encode_block(WMACodecContext *s, float (*src_coefs)[BLOCK_MAX_SIZE],
             if(run)
                 put_bits(&s->pb, s->coef_vlcs[tindex]->huffbits[1], s->coef_vlcs[tindex]->huffcodes[1]);
         }
-        if (s->version == 1 && s->nb_channels >= 2) {
+        if (s->version == 1 && s->avctx->channels >= 2) {
             avpriv_align_put_bits(&s->pb);
         }
     }
@@ -343,7 +343,7 @@ static int encode_frame(WMACodecContext *s, float (*src_coefs)[BLOCK_MAX_SIZE],
 
     avpriv_align_put_bits(&s->pb);
 
-    return put_bits_count(&s->pb)/8 - s->block_align;
+    return put_bits_count(&s->pb) / 8 - s->avctx->block_align;
 }
 
 static int encode_superframe(AVCodecContext *avctx, AVPacket *avpkt,
@@ -413,7 +413,7 @@ static int encode_superframe(AVCodecContext *avctx, AVPacket *avpkt,
     if (frame->pts != AV_NOPTS_VALUE)
         avpkt->pts = frame->pts - ff_samples_to_time_base(avctx, avctx->delay);
 
-    avpkt->size = s->block_align;
+    avpkt->size = avctx->block_align;
     *got_packet_ptr = 1;
     return 0;
 }
-- 
1.7.9.5


From 292a08cbab3392a693b1c3b03a9cac6a1b65d304 Mon Sep 17 00:00:00 2001
From: Anton Khirnov <anton@khirnov.net>
Date: Sat, 20 Oct 2012 17:15:57 +0200
Subject: [PATCH 013/278] asfdec: cosmetics, reformat ff_asf_parse_packet()

---
 libavformat/asfdec.c |  138 ++++++++++++++++++++++++++------------------------
 1 file changed, 72 insertions(+), 66 deletions(-)

diff --git a/libavformat/asfdec.c b/libavformat/asfdec.c
index 5fe8e96..c6b322d 100644
--- a/libavformat/asfdec.c
+++ b/libavformat/asfdec.c
@@ -1002,13 +1002,15 @@ static int ff_asf_parse_packet(AVFormatContext *s, AVIOContext *pb, AVPacket *pk
     ASFStream *asf_st = 0;
     for (;;) {
         int ret;
-        if(pb->eof_reached)
+
+        if (pb->eof_reached)
             return AVERROR_EOF;
-        if (asf->packet_size_left < FRAME_HEADER_SIZE
-            || asf->packet_segments < 1) {
-            //asf->packet_size_left <= asf->packet_padsize) {
+
+        if (asf->packet_size_left < FRAME_HEADER_SIZE ||
+            asf->packet_segments < 1) {
             int ret = asf->packet_size_left + asf->packet_padsize;
-            assert(ret>=0);
+
+            assert(ret >= 0);
             /* fail safe */
             avio_skip(pb, ret);
 
@@ -1019,19 +1021,19 @@ static int ff_asf_parse_packet(AVFormatContext *s, AVIOContext *pb, AVPacket *pk
             return 1;
         }
         if (asf->packet_time_start == 0) {
-            if(asf_read_frame_header(s, pb) < 0){
-                asf->packet_segments= 0;
+            if (asf_read_frame_header(s, pb) < 0) {
+                asf->packet_segments = 0;
                 continue;
             }
-            if (asf->stream_index < 0
-                || s->streams[asf->stream_index]->discard >= AVDISCARD_ALL
-                || (!asf->packet_key_frame && s->streams[asf->stream_index]->discard >= AVDISCARD_NONKEY)
-                ) {
+            if (asf->stream_index < 0 ||
+                s->streams[asf->stream_index]->discard >= AVDISCARD_ALL ||
+                (!asf->packet_key_frame &&
+                 s->streams[asf->stream_index]->discard >= AVDISCARD_NONKEY)) {
                 asf->packet_time_start = 0;
                 /* unhandled packet (should not happen) */
                 avio_skip(pb, asf->packet_frag_size);
                 asf->packet_size_left -= asf->packet_frag_size;
-                if(asf->stream_index < 0)
+                if (asf->stream_index < 0)
                     av_log(s, AV_LOG_ERROR, "ff asf skip %d (unknown stream)\n", asf->packet_frag_size);
                 continue;
             }
@@ -1042,12 +1044,11 @@ static int ff_asf_parse_packet(AVFormatContext *s, AVIOContext *pb, AVPacket *pk
         if (asf->packet_replic_size == 1) {
             // frag_offset is here used as the beginning timestamp
             asf->packet_frag_timestamp = asf->packet_time_start;
-            asf->packet_time_start += asf->packet_time_delta;
-            asf->packet_obj_size = asf->packet_frag_size = avio_r8(pb);
+            asf->packet_time_start    += asf->packet_time_delta;
+            asf->packet_obj_size       = asf->packet_frag_size = avio_r8(pb);
             asf->packet_size_left--;
             asf->packet_multi_size--;
-            if (asf->packet_multi_size < asf->packet_obj_size)
-            {
+            if (asf->packet_multi_size < asf->packet_obj_size) {
                 asf->packet_time_start = 0;
                 avio_skip(pb, asf->packet_multi_size);
                 asf->packet_size_left -= asf->packet_multi_size;
@@ -1055,29 +1056,30 @@ static int ff_asf_parse_packet(AVFormatContext *s, AVIOContext *pb, AVPacket *pk
             }
             asf->packet_multi_size -= asf->packet_obj_size;
         }
-        if(   /*asf->packet_frag_size == asf->packet_obj_size*/
-              asf_st->frag_offset + asf->packet_frag_size <= asf_st->pkt.size
-           && asf_st->frag_offset + asf->packet_frag_size > asf->packet_obj_size){
+        if (asf_st->frag_offset + asf->packet_frag_size <= asf_st->pkt.size &&
+            asf_st->frag_offset + asf->packet_frag_size > asf->packet_obj_size) {
             av_log(s, AV_LOG_INFO, "ignoring invalid packet_obj_size (%d %d %d %d)\n",
-                asf_st->frag_offset, asf->packet_frag_size,
-                asf->packet_obj_size, asf_st->pkt.size);
-            asf->packet_obj_size= asf_st->pkt.size;
+                   asf_st->frag_offset, asf->packet_frag_size,
+                   asf->packet_obj_size, asf_st->pkt.size);
+            asf->packet_obj_size = asf_st->pkt.size;
         }
 
-        if (   asf_st->pkt.size != asf->packet_obj_size
-            || asf_st->frag_offset + asf->packet_frag_size > asf_st->pkt.size) { //FIXME is this condition sufficient?
-            if(asf_st->pkt.data){
-                av_log(s, AV_LOG_INFO, "freeing incomplete packet size %d, new %d\n", asf_st->pkt.size, asf->packet_obj_size);
+        if (asf_st->pkt.size != asf->packet_obj_size ||
+            //FIXME is this condition sufficient?
+            asf_st->frag_offset + asf->packet_frag_size > asf_st->pkt.size) {
+            if (asf_st->pkt.data) {
+                av_log(s, AV_LOG_INFO, "freeing incomplete packet size %d, "
+                       "new %d\n", asf_st->pkt.size, asf->packet_obj_size);
                 asf_st->frag_offset = 0;
                 av_free_packet(&asf_st->pkt);
             }
             /* new packet */
             av_new_packet(&asf_st->pkt, asf->packet_obj_size);
-            asf_st->seq = asf->packet_seq;
-            asf_st->pkt.dts = asf->packet_frag_timestamp - asf->hdr.preroll;
+            asf_st->seq              = asf->packet_seq;
+            asf_st->pkt.dts          = asf->packet_frag_timestamp - asf->hdr.preroll;
             asf_st->pkt.stream_index = asf->stream_index;
-            asf_st->pkt.pos =
-            asf_st->packet_pos= asf->packet_pos;
+            asf_st->pkt.pos          = asf_st->packet_pos = asf->packet_pos;
+
             if (asf_st->pkt.data && asf_st->palette_changed) {
                 uint8_t *pal;
                 pal = av_packet_new_side_data(&asf_st->pkt, AV_PKT_DATA_PALETTE,
@@ -1108,18 +1110,19 @@ static int ff_asf_parse_packet(AVFormatContext *s, AVIOContext *pb, AVPacket *pk
         if (asf->packet_size_left < 0)
             continue;
 
-        if(   asf->packet_frag_offset >= asf_st->pkt.size
-           || asf->packet_frag_size > asf_st->pkt.size - asf->packet_frag_offset){
+        if (asf->packet_frag_offset >= asf_st->pkt.size ||
+            asf->packet_frag_size > asf_st->pkt.size - asf->packet_frag_offset) {
             av_log(s, AV_LOG_ERROR, "packet fragment position invalid %u,%u not in %u\n",
-                asf->packet_frag_offset, asf->packet_frag_size, asf_st->pkt.size);
+                   asf->packet_frag_offset, asf->packet_frag_size, asf_st->pkt.size);
             continue;
         }
 
         ret = avio_read(pb, asf_st->pkt.data + asf->packet_frag_offset,
-                         asf->packet_frag_size);
+                        asf->packet_frag_size);
         if (ret != asf->packet_frag_size) {
             if (ret < 0 || asf->packet_frag_offset + ret == 0)
                 return ret < 0 ? ret : AVERROR_EOF;
+
             if (asf_st->ds_span > 1) {
                 // scrambling, we can either drop it completely or fill the remainder
                 // TODO: should we fill the whole packet instead of just the current
@@ -1127,9 +1130,10 @@ static int ff_asf_parse_packet(AVFormatContext *s, AVIOContext *pb, AVPacket *pk
                 memset(asf_st->pkt.data + asf->packet_frag_offset + ret, 0,
                        asf->packet_frag_size - ret);
                 ret = asf->packet_frag_size;
-            } else
+            } else {
                 // no scrambling, so we can return partial packets
                 av_shrink_packet(&asf_st->pkt, asf->packet_frag_offset + ret);
+            }
         }
         if (s->key && s->keylen == 20)
             ff_asfcrypt_dec(s->key, asf_st->pkt.data + asf->packet_frag_offset,
@@ -1138,11 +1142,11 @@ static int ff_asf_parse_packet(AVFormatContext *s, AVIOContext *pb, AVPacket *pk
         /* test if whole packet is read */
         if (asf_st->frag_offset == asf_st->pkt.size) {
             //workaround for macroshit radio DVR-MS files
-            if(   s->streams[asf->stream_index]->codec->codec_id == AV_CODEC_ID_MPEG2VIDEO
-               && asf_st->pkt.size > 100){
+            if (s->streams[asf->stream_index]->codec->codec_id == AV_CODEC_ID_MPEG2VIDEO &&
+                asf_st->pkt.size > 100) {
                 int i;
-                for(i=0; i<asf_st->pkt.size && !asf_st->pkt.data[i]; i++);
-                if(i == asf_st->pkt.size){
+                for (i = 0; i < asf_st->pkt.size && !asf_st->pkt.data[i]; i++);
+                if (i == asf_st->pkt.size) {
                     av_log(s, AV_LOG_DEBUG, "discarding ms fart\n");
                     asf_st->frag_offset = 0;
                     av_free_packet(&asf_st->pkt);
@@ -1152,37 +1156,39 @@ static int ff_asf_parse_packet(AVFormatContext *s, AVIOContext *pb, AVPacket *pk
 
             /* return packet */
             if (asf_st->ds_span > 1) {
-              if(asf_st->pkt.size != asf_st->ds_packet_size * asf_st->ds_span){
-                    av_log(s, AV_LOG_ERROR, "pkt.size != ds_packet_size * ds_span (%d %d %d)\n", asf_st->pkt.size, asf_st->ds_packet_size, asf_st->ds_span);
-              }else{
-                /* packet descrambling */
-                uint8_t *newdata = av_malloc(asf_st->pkt.size + FF_INPUT_BUFFER_PADDING_SIZE);
-                if (newdata) {
-                    int offset = 0;
-                    memset(newdata + asf_st->pkt.size, 0, FF_INPUT_BUFFER_PADDING_SIZE);
-                    while (offset < asf_st->pkt.size) {
-                        int off = offset / asf_st->ds_chunk_size;
-                        int row = off / asf_st->ds_span;
-                        int col = off % asf_st->ds_span;
-                        int idx = row + col * asf_st->ds_packet_size / asf_st->ds_chunk_size;
-                        assert(offset + asf_st->ds_chunk_size <= asf_st->pkt.size);
-                        assert(idx+1 <= asf_st->pkt.size / asf_st->ds_chunk_size);
-                        memcpy(newdata + offset,
-                               asf_st->pkt.data + idx * asf_st->ds_chunk_size,
-                               asf_st->ds_chunk_size);
-                        offset += asf_st->ds_chunk_size;
+                if(asf_st->pkt.size != asf_st->ds_packet_size * asf_st->ds_span) {
+                    av_log(s, AV_LOG_ERROR, "pkt.size != ds_packet_size * "
+                           "ds_span (%d %d %d)\n", asf_st->pkt.size,
+                           asf_st->ds_packet_size, asf_st->ds_span);
+                } else {
+                    /* packet descrambling */
+                    uint8_t *newdata = av_malloc(asf_st->pkt.size + FF_INPUT_BUFFER_PADDING_SIZE);
+                    if (newdata) {
+                        int offset = 0;
+                        memset(newdata + asf_st->pkt.size, 0, FF_INPUT_BUFFER_PADDING_SIZE);
+                        while (offset < asf_st->pkt.size) {
+                            int off = offset / asf_st->ds_chunk_size;
+                            int row = off / asf_st->ds_span;
+                            int col = off % asf_st->ds_span;
+                            int idx = row + col * asf_st->ds_packet_size / asf_st->ds_chunk_size;
+                            assert(offset + asf_st->ds_chunk_size <= asf_st->pkt.size);
+                            assert(idx+1 <= asf_st->pkt.size / asf_st->ds_chunk_size);
+                            memcpy(newdata + offset,
+                                   asf_st->pkt.data + idx * asf_st->ds_chunk_size,
+                                   asf_st->ds_chunk_size);
+                            offset += asf_st->ds_chunk_size;
+                        }
+                        av_free(asf_st->pkt.data);
+                        asf_st->pkt.data = newdata;
                     }
-                    av_free(asf_st->pkt.data);
-                    asf_st->pkt.data = newdata;
                 }
-              }
             }
-            asf_st->frag_offset = 0;
-            *pkt= asf_st->pkt;
-            asf_st->pkt.size = 0;
-            asf_st->pkt.data = 0;
+            asf_st->frag_offset         = 0;
+            *pkt                        = asf_st->pkt;
+            asf_st->pkt.size            = 0;
+            asf_st->pkt.data            = 0;
             asf_st->pkt.side_data_elems = 0;
-            asf_st->pkt.side_data = NULL;
+            asf_st->pkt.side_data       = NULL;
             break; // packet completed
         }
     }
-- 
1.7.9.5

